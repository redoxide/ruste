grammar de.redoxi.ruste.Rust hidden(WS, SL_COMMENT, ML_COMMENT)

generate rust "http://www.redoxi.de/ruste/grammar/Rust" 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// Top level crate and its implicit module
Crate:
	attrs+=CrateAttr*
	items+=CrateItem*
;

ViewItem:
	attrs+=ItemAttr* use=UseDecl
;

LinkAttr:
	ident=ID ('=' value=Literal)?
;

// TODO Match rules for internal vs external paths
UseDecl:
	// vis=Visibility? "use" (name=ID '=' aliasedPath=/*Path*/QualifiedNameWithWildcard | (mods+=[ModItem] "::")* (name=ID | wildcard?='*' | '{' items+=ID (',' items+=ID)* '}')) ';'
	vis=Visibility? "use" (name=ID '=' importedNamespace=QualifiedName | importedNamespace=QualifiedNameWithWildcard) ';'
;

QualifiedName:
	ID ("::" ID)*
;

QualifiedNameWithWildcard:
	 QualifiedName ("::*" | "::{" ID (',' ID)* '}')?
;

// Declarations or imports of types that can be referenced in place of types
TypeDecl:
	UseDecl | TypeItem | StructItem | EnumItem | TraitItem
;

Container:
	UseDecl | ModItem
;

/*Path:
	FullyQualifiedPath |
	AliasedPath
;

FullyQualifiedPath:
	
;

// Path starting with a reference to a `use' statement
AliasedPath:
	head=[UseDecl] ("::" )
;*/

// Attribute for a crate
CrateAttr:
	'#![' attrs+=Attr (',' attrs+=Attr)* ']' ';'?
;

// Attribute for an item
ItemAttr:
	'#[' attrs+=Attr (',' attrs+=Attr)* ']' ';'?
;

// Individual attribute within an item
Attr: 
	name=ID ('=' value=Literal | '(' attrs+=Attr (',' attrs+=Attr)* ')')?
;

CrateItem:
	attrs+=ItemAttr* item=Item
;

// An item and any associated attributes
ItemAndAttrs:
	attrs+=ItemAttr* item=Item
;

Item:
	ModItem | ImplItem | TypeDecl | FnItem
;

NamedItem:
	ModItem | TypeDecl | FnItem | TraitItem | EnumVariant | StructItem | StaticItem | UseDecl | SlotDeclStmt | FieldPat | PatVariable
;

// A module declaration item
ModItem:
	vis=Visibility? "mod" name=ID (externalBody?=';' | '{' items+=ItemAndAttrs* '}') |
	{ExternModDecl} ("extern" "crate") name=ID ('(' attrs += LinkAttr (',' attrs += LinkAttr)* ')')? ('=' externalIdent=StringLit)? ';'
;

// Function item
FnItem:
	vis=Visibility? "fn" name=ID ('<' params += GenericParamDecl (',' params += GenericParamDecl)* '>')? ('(' (args+=Arg (','  args+=Arg)*)? ')' | '()') ("->" returnType=Type)? '{' body=Block '}'
;

// TODO Reference Type?
TypeItem:
	vis=Visibility? "type" name=ID ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? '=' type=Type ';'
;

StructItem:
	vis=Visibility? "struct" name=ID ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? '{' fields+=StructDeclField (',' fields+=StructDeclField)* ','? '}'
;

EnumItem:
	vis=Visibility? "enum" name=ID ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? "{" variants+=EnumVariant ("," variants+=EnumVariant)* ','? "}"
;

EnumVariant:
	name=ID ('<' params+=ID (',' params+=ID)* '>')? ("(" types+=Type ("," types+=Type)* ")" | "{" fields+=StructDeclField ("," fields+=StructDeclField)* /* TODO Wildcard pattern? */ "}")?
;

TraitItem:
	vis=Visibility? "trait" name=ID ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? "{" (methods+=TraitMethod)* "}"
;

TraitMethod:
	(unsafe?="unsafe" | extern?="extern")? vis=Visibility? "fn" name=ID ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? ('(' args+=FirstArg (',' args+=Arg)* ')' | '()') ("->" returnType=Type)? ('{' body=Block '}' | ';')
;

// TODO Crossreference struct and trait
ImplItem:
	"impl" ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? types+=TypePath ("for" types+=TypePath)? "{" (methods+=ImplMethod)* "}"
;

ImplMethod:
	attrs+=ItemAttr* (unsafe?="unsafe" | extern?="extern")? vis=Visibility? "fn" name=ID ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? ('(' (args+=FirstArg)? (',' args+=Arg)* ')' | '()') ("->" returnType=Type)? '{' body=Block '}'
;

/*ExternItem:
	"extern" ({ExternModDecl} "crate" name=ID ('(' attrs += LinkAttr (',' attrs += LinkAttr)* ')')? ('=' externalIdent=StringLit)? ';'| {ExternBlock} abi=STRING? "{" (functions += ForeignFn)* "}")
;*/

ForeignFn:
	"fn" name=ID ("(" (args+=Arg ("," args+=Arg)*)? ")" | '()') ("->" returnType=Type)? ";"
;

StaticItem:
	vis=Visibility? "static" mutable?="mut"? name=ID (":" type=Type)? "=" expr=Expr ";"
;

Expr:
	ExprNonBlock
;

// Expressions ending in a block that don't need to have a trailing semicolon in a list of statements
ExprBlock:
	ExprMatch | 
	ExprIf | 
	ExprFor | 
	ExprDo | 
	ExprWhile |
	ExprLoop
;

ExprNonBlock:
	ExprBinary |
	ExprLambda |
	ExprBreak |
	ExprContinue |
	ExprReturn
;

ExprLValue:
	expr=ExprLeaf ({ExprField.expr=current} =>'.' field=ID | {ExprIndex.expr=current} =>'[' indexExpr=Expr ']')
;

ExprLeaf:
	ExprPrimary
;

ExprFnCallArgs:
	{ExprFnCallArgs} ('()' | '(' args+=Expr (',' args+=Expr)* ')') tail=ExprFnCallArgs?
;

ExprPrimary:
	ExprLiteral |
	ExprGroup |
	ExprStruct |
	ExprVec |
	ExprOwnedClosure |
	ExprPathOrCreate |
	ExprSelf |
	ExprUnit |
	ExprBlock
;

ExprLiteral:
	literal=Literal
;

ExprPath:
	//{ExprPath} (segments+=[Container] "::" (mods+=[ModItem] "::")*)? segments+=[NamedItem] ('::<' genericParams+=GenericParam (',' genericParams+=GenericParam)* '>')?
	{ExprPath} path=[NamedItem|QualifiedName] ('::<' genericParams+=GenericParam (',' genericParams+=GenericParam)* '>')?
;

ExprPathOrCreate:
	path=ExprPath (
		// TODO Struct literal can have ".." token here (see line 2611 of parser.rs)
		=>("{" fields+=StructField) ("," fields+=StructField)* ','? "}" | 
		macro?='!'? =>('()' | '(' exprs+=Expr (',' exprs+=Expr)* ','? ')') | 
		=>'[' indexExpr=Expr ']'
	)?
;

ExprSelf:
	{ExprSelf} "self"
;

ExprGroup:
	'(' expr=Expr ({ExprTuple.exprs+=current} ',' (exprs+=Expr (',' exprs+=Expr)* ','?)?)? ')'
;

ExprStruct:
	"{" fields+=StructDeclField ("," fields+=StructDeclField)* (".." baseExpr = Expr)? "}"
;

ExprVec:
	// {ExprVec} '[' mutable?="mut"? (exprs+=Expr ',' (('..' lenExpr=Expr) | exprs+=Expr (',' exprs+=Expr)+ ','?))? ']'
	{ExprVec} '[' mutable?="mut"? (exprs+=Expr (',' (".." lenExpr=Expr | exprs+=Expr (',' exprs+=Expr)* ','?))?)? ']'
;

ExprOwnedClosure:
	// TODO Expr rather than block as optional tail
	"proc" ('()' | '(' args+=Pat (',' args+=Pat)* ')') '{' block=Block '}'
;

ExprUnary:
	NumericNegation |
	Dereference |
	LogicalNegation |
	ManagedBox |
	OwnedBox |
	Borrow |
	ExprFields
;

ExprUnit:
	{ExprUnit} '()'
;

// TODO ExprPrimary should include field access and method calls
NumericNegation:
	"-" expr=ExprUnary
;

Dereference:
	"*" expr=ExprUnary
;

LogicalNegation:
	"!" expr=ExprUnary
;

ManagedBox:
	"@" expr=ExprUnary
;

OwnedBox:
	"~" expr=ExprUnary
;

Borrow:
	"&" mutable?="mut"? expr=ExprUnary
;

ExprFields:
	ExprLeaf ({ExprFields.exprs+=current} '.' exprs+=ExprFieldOrMethodCall)*
;

ExprFieldOrMethodCall:
	name=ID (args=ExprFnCallArgs)?
;

ExprBinary:
	Assign
;

enum MultiplicativeOp:
	DIV="/" | MUL="*" | MOD="%"
;

enum AdditiveOp:
	ADD="+" | SUB="-"
;

enum ShiftOp:
	LSHIFT="<<" | RSHIFT=">>"
;

enum ComparisonOp:
	LESS_THAN="<" | GREATER_THAN=">" | LESS_THAN_OR_EQUAL="<=" | GREATER_THAN_OR_EQUAL=">="
;

enum EqualityOp:
	EQUAL="==" | NOT_EQUAL="!="
;

enum AssignmentOp:
	ASSIGN="=" |
	ADD_ASSIGN="+=" |
	SUB_ASSIGN="-=" |
	MUL_ASSIGN="*=" |
	DIV_ASSIGN="/=" |
	MOD_ASSIGN="%=" |
	AND_ASSIGN="&=" |
	OR_ASSIGN="|=" |
	XOR_ASSIGN="^=" |
	LSHIFT_ASSIGN="<<=" |
	RSHIFT_ASSIGN=">>="
;

DivisionMultiplicationOrModulo:
	ExprUnary ({ExprMultiplicative.exprs+=current} ops+=MultiplicativeOp exprs+=ExprUnary (ops+=MultiplicativeOp exprs+=ExprUnary)*)?
;

As:
	DivisionMultiplicationOrModulo ({ExprCast.expr=current} 'as' type=Type)?
;

AdditionOrSubtraction:
	As ({ExprAdditive.exprs+=current} ops+=AdditiveOp exprs+=As ( ops+=AdditiveOp exprs+=As)*)?
;

ShiftOperator:
	AdditionOrSubtraction ({ExprShift.exprs+=current} ops+=ShiftOp exprs+=AdditionOrSubtraction (ops+=ShiftOp exprs+=AdditionOrSubtraction)*)?
;

BitwiseAnd:
	ShiftOperator ({ExprBitwiseAnd.exprs+=current} "&" exprs+=ShiftOperator ("&" exprs+=ShiftOperator)*)?
;

BitwiseXor:
	BitwiseAnd ({ExprBitwiseXor.exprs+=current} "^" exprs+=BitwiseAnd ("^" exprs+=BitwiseAnd)*)?
;

BitwiseOr:
	BitwiseXor ({ExprBitwiseOr.exprs+=current} "|" exprs+=BitwiseXor ("|" exprs+=BitwiseXor)*)?
;

ComparisonOperators:
	BitwiseOr ({ExprComparision.exprs+=current} ops+=ComparisonOp exprs+=BitwiseOr (ops+=ComparisonOp exprs+=BitwiseOr)*)?
;

EqualityOperator:
	ComparisonOperators ({ExprEqual.exprs+=current} ops+=EqualityOp exprs+=ComparisonOperators (ops+=EqualityOp exprs+=ComparisonOperators)*)?
;

BooleanAnd:
	EqualityOperator ({ExprBooleanAnd.exprs+=current} "&&" exprs+=EqualityOperator ("&&" exprs+=EqualityOperator)*)?
;

BooleanOr:
	BooleanAnd ({ExprBooleanOr.exprs+=current} "||" exprs+=BooleanAnd ("||" exprs+=BooleanAnd)*)?
;

// TODO Divide expressions into lvalues and rvalues
Assign:
	BooleanOr ({ExprAssign.exprs+=current} ops+=AssignmentOp exprs+=BooleanOr (ops+=AssignmentOp exprs+=BooleanOr)*)?
;

ExprLambda:
	('|' (args+=Pat (',' args+=Pat)*)? '|' | "||") (expr=Expr | '{' block=Block '}')
;

ExprWhile:
	"while" expr=Expr '{' block=Block '}'
;

ExprLoop:
	(lifetime=[Lifetime] ':')? 'loop' '{' block=Block '}'
;

ExprBreak:
	{ExprBreak} 'break' lifetime=[Lifetime]?
;

ExprContinue:
	{ExprContinue} 'continue' lifetime=[Lifetime]?
;

ExprDo:
	'do' expr=Expr '|' (args+=ID (',' args+=ID)*)? '|' '{' block=Block '}'
;

ExprFor:
	'for' pat=Pat 'in' expr=Expr '{' block=Block '}'
;

ExprIf:
	'if' expr=Expr '{' block=Block '}' else=ElseTail?
;

ElseTail:
	'else' (ExprIf | '{' block=Block '}')
;

ExprMatch:
	'match' expr=Expr '{' arms=MatchArm? '}'
;

MatchArm:
	matchPats+=MatchPat ('|' matchPats+=MatchPat)* ("if" ifExpr=Expr)? '=>' (expr=Expr (',' nextMatch=MatchArm?)? | '{' block=Block '}' nextMatch=MatchArm?) 
;

MatchPat:
	pat=Pat ('..' endPat=Pat)?
;

ExprReturn:
	{ExprReturn} 'return' =>expr=Expr?
;

Block:
	{Block} =>(viewItems+=ViewItem)* =>(stmts+=Stmt)* expr=Expr?
;

Stmt:
	SlotDeclStmt |
	=>ExprBlock |
	ExprStmt |
	ItemAndAttrs
;

SlotDeclStmt:
	"let" pat=Pat (':' type=Type)? ('=' expr=Expr)? ';'
;

ExprStmt:
	(expr=ExprNonBlock ';')
;

// TODO Crossreference Trait?
GenericParamDecl:
	name=ID (':' bounds+=ID ('+' bounds+=ID)* )? |
	{Lifetime} LIFETIME
;

// TODO Crossreference Type
Arg:
	pat=Pat ':' type=Type
;

FirstArg:
	// TODO Reduce rule set for pattern
	pat=Pat (':' type=Type)?
;

// TODO Expand
// See line 2869 of libsyntax/parse/parser.rs
Pat:
	PatWildcard |														
	PatEnum |
	PatVariable |
	PatBoxed |
	PatOwned |
	PatBorrowed |
	PatTuple |
	PatVector |
	PatLiteral |
	PatRef |
	PatRaw
;

PatWildcard:
	{PatWildcard} '_'
;

PatBoxed:
	"@" pattern=Pat
;

PatOwned:
	"~" pattern=Pat
;

PatBorrowed:
	"&" pattern=Pat
;

PatRaw:
	'*' pattern=Pat
;

PatTuple:
	'(' patterns+=Pat (',' patterns+=Pat)* ')'
;

PatVector:
	'[' patterns+=Pat (',' patterns+=Pat)* ']'
;

PatLiteral:
	literal=Literal
;

PatRef:
	"ref" pat=Pat
;

PatEnum:
	{PatEnum} mutable?="mut"? ("self" | path=ExprPath =>(
		{PatTupleEnum.path=current} '(' ('*' | '..' | (patterns+=Pat (',' patterns+=Pat)*)) ')' | 
		// TODO Check parser for production after ".."
		{PatStructEnum.path=current} '{' fieldPatterns+=FieldPat (',' fieldPatterns+=FieldPat)* (',' ".." expr=Expr?)? '}' 
	))
;

PatVariable:
	mutable?="mut"? name=ID
;

FieldPat:
	// TODO Shouldn't this be a Type?
	name=ID (':' pattern=Pat)?
;

TypePath:
	mutable?="mut"? type=[NamedItem|QualifiedName] (=>'<' genericParams+=GenericParam (',' genericParams+=GenericParam)* '>')?
;

GenericParam:
	Type | {Lifetime} name=LIFETIME
;

terminal LIFETIME:
	"'" ID
;

Type:
	UnitType |
	TypePath |
	BoxedPointer |
	OwnedPointer |
	BorrowedPointer |
	RawPointer |
	VectorType |
	TypeItem |
	LambdaType |
	TupleType |
	{PrimitiveType} PrimitiveType
;

UnitType:
	{UnitType} '()'
;

BoxedPointer:
	"@" type=Type
;

OwnedPointer:
	"~" type=Type
;

// TODO Reference lifetime in generic parameter declaration
BorrowedPointer:
	"&"(lifetime=LIFETIME)? type=Type
;

RawPointer:
	'*' type=Type
;

VectorType:
	'[' type=Type ']'
;

LambdaType:
	// TODO This should really be a list of types
	{LambdaType} ('|' (=>args+=OptionallyNamedArg (',' types+=OptionallyNamedArg)*)? '|' | "||") ('->' returnType=Type)?
;

OptionallyNamedArg:
	=>(pat=Pat ':')? type=Type
;

TupleType:
	'(' types+=Type (',' types+=Type)+ ')'
;

PrimitiveType:
	INT_TYPE | UINT_TYPE | FLOAT_TYPE | BOOL_TYPE | TEXT_TYPE
;

terminal TEXT_TYPE: "char" | "str";
terminal INT_TYPE: "int" | I8 | I16 | I32 | I64;
terminal UINT_TYPE: "uint" | U8 | U16 | U32 | U64;
terminal FLOAT_TYPE: F32 | F64;
terminal BOOL_TYPE:	"bool";

StructDeclField:
	vis=Visibility? name=ID ':' type=Type
;

StructField:
	(name=ID ':' expr=Expr)
;

Variant:
	StructVariant | TupleVariant | UnitVariant
;

StructVariant:
	name=ID ('<' params += GenericParamDecl (',' params += GenericParamDecl)* '>')? '{' fields+=StructDeclField (',' fields+=StructDeclField)* '}'
;

TupleVariant:
	name=ID '(' types+=Type (',' types+=Type)* ')'
;

UnitVariant:
	name=ID
;

enum Visibility:
	PRIVATE="priv" | PUBLIC="pub"	
;

// TODO Add all keywords

// terminal INT_TYPE: INT_SIZE;
terminal fragment INT_SIZE: SIGNED_INT_TYPE | UNSIGNED_INT_TYPE;
terminal fragment SIGNED_INT_TYPE: I | I8 | I16 | I32 | I64;
terminal fragment I: "i";
terminal fragment I8: "i8";
terminal fragment I16: "i16";
terminal fragment I32: "i32";
terminal fragment I64: "i64";
terminal fragment UNSIGNED_INT_TYPE: U | U8 | U16 | U32 | U64;
terminal fragment U: "u";
terminal fragment U8: "u8";
terminal fragment U16: "u16";
terminal fragment U32: "u32";
terminal fragment U64: "u64";
// terminal FLOAT_TYPE: FLOAT_SIZE;
terminal fragment FLOAT_SIZE: F32 | F64;
terminal fragment F32: "f32";
terminal fragment F64: "f64";
// terminal MACHINE_TYPE: MACHINE_INT_TYPE | MACHINE_UINT_TYPE;

StringLit: 
	value = STRING
	// | {RawStringLit} 'r' '#' body = RawString? '#'
;

// Literal value
Literal:
	NumberLit | CharLit | StringLit
;

NumberLit:
	floatValue=FLOAT | intValue=INT
;

// Single character literal
CharLit:
	value=CHAR
;

terminal CHAR: "'" (('\\' ('\\' | 'n' | 'r' | 't' | '0' | "'")) | UNICODE_CHAR | !('\\' | "'")) "'";
terminal STRING: '"' (('\\' ('\\' | 'n' | 'r' | 't' | '0' | '"' | '\n')) | UNICODE_CHAR | !('\\' | '"'))* '"';

terminal fragment UNICODE_CHAR: UTF8_CHAR | UTF16_CHAR | UTF32_CHAR;
terminal fragment UTF8_CHAR: '\\x' HEX_DIGIT HEX_DIGIT;
terminal fragment UTF16_CHAR: '\\u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
terminal fragment UTF32_CHAR: '\\U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

// Floating point literal
terminal FLOAT: DEC_DIGIT (DEC_DIGIT | '_')* ('.' (DEC_DIGIT | '_')+) (('E' | 'e') ('+' | '-')? (DEC_DIGIT | '_')+)? FLOAT_SIZE?;

// Integer literal
terminal INT: (DEC_INT_LIT | BIN_INT_LIT | OCT_INT_LIT | HEX_INT_LIT) INT_SIZE?;

// Decimal (base 10) integer
terminal fragment DEC_INT_LIT: DEC_DIGIT (DEC_DIGIT | '_')*;

// Binary (base 2) integer
terminal fragment BIN_INT_LIT: "0b" ('0' | '1' | '_')+;

// Octal (base 8) integer
terminal fragment OCT_INT_LIT: "0o" (OCT_DIGIT | '_')+;

// Hex (base 16) integer
terminal fragment HEX_INT_LIT: "0x" (HEX_DIGIT | '_')+;

terminal fragment OCT_DIGIT: '0'..'7';
terminal fragment DEC_DIGIT: '0'..'9';
terminal fragment HEX_DIGIT: '0'..'9' | 'a'..'f' | 'A'..'F';

// terminal fragment NON_SPECIAL_CHAR: !('"' | '\'' | '\\' | 'n' | 'r' | 't' | '0');

terminal ID: ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS: (' ' | '\t' | '\r' | '\n')+;
terminal ANY_OTHER: .;
