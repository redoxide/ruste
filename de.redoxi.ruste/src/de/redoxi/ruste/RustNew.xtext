grammar de.redoxi.ruste.Rust hidden(WS, SL_COMMENT, ML_COMMENT)

generate rust "http://www.redoxi.de/ruste/grammar/Rust"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// parse_crate_mod, libsyntax/parser/parser.rs, line 5087
Crate:
// parse_inner_attrs_and_next
// parse_items_and_view_items, libsyntax/parser/parser.rs, line 4965
	(innerAttrs+=InnerAttributes)*
	// parse_mod_items
	(items+=(ViewItem /*| Item*/))*;

InnerAttributes:
	POUND NOT LBRACKET metaItem=MetaItem RBRACKET;

OuterAttributes:
	attributes+=Attribute+;

	// parse_attribute, libsyntax/parser/attr.rs, line 62
Attribute:
	POUND LBRACKET metaItem=MetaItem RBRACKET;

	// parse_meta_item, libsyntax/parser/attr.rs, line 154
MetaItem:
	name=ID (EQ value=Lit | LPAREN value=MetaList RPAREN)?;

	// parse_lit, libsyntax/parser/parser.rs, line 1426
Lit hidden():
	{BoolLit} value=(TRUE_KW | FALSE_KW) |
	// lit_from_token, libsyntax/parser/parser.rs, line 1402
	{LitChar} value=CHAR | {LitInt} value=INT | {LitUint} value=UINT | {LitIntSuffixed} value=INT_UNSUFFIXED | {LitFloat}
	value=FLOAT | {LitFloatUnsuffixed} value=FLOAT_UNSUFFIXED | {LitString} value=STRING |
	// TODO {LitRawString}
	{LitUnit} LPAREN RPAREN;

	// parse_meta_seq, libsyntax/parser/attr.rs, line 196
MetaList:
	metaItems+=MetaItem (COMMA metaItems+=MetaItem);

ViewItem:
// parse_item_or_view_item, libsyntax/parser/parser.rs, line 4546
	ViewItemUse |
	ViewExternItem;

ViewItemUse:
// parse_item_or_view_item, libsyntax/parser/parser.rs, line 4818
	USE_KW path=ViewPath;

	// parse_view_paths, libsyntax/parser/parser.rs, line 4951
ViewPath:
	ViewPathSimple | ViewPathGlob | ViewPathList;

	// TODO NonGlobalPath?
Path:
	segments+=ID (MOD_SEP segments+=ID)*;

	// parse_view_paths, libsyntax/parser/parser.rs, line 4848
ViewPathSimple:
	name=ID => EQ path=Path;

	// parse_view_paths, libsyntax/parser/parser.rs, line 4875
ViewPathGlob:
	path=Path => "::*";

	// parse_view_paths, libsyntax/parser/parser.rs, line 4875
ViewPathList:
	path=Path => "::{" identifiers+=ID (COMMA identifiers+=ID)* RBRACE;

ViewExternItem:
	ViewItemExternCrate | ViewItemExternFn;

	// parse_item_extern_crate, libsyntax/parser/parser.rs, line 4318
ViewItemExternCrate:
	EXTERN_KW => CRATE_KW name=ID (EQ path=STRING)? SEMI;

ViewItemExternFn:
	EXTERN_KW (abi=STRING)? => fn=FnItem;

	// parse_item_fn, libsyntax/parser/parser.rs, line 3791
FnItem:
// parse_fn_header
// parse_fn_decl
// parse_inner_attrs_and_block
	FN_KW name=ID generics=Generics decl=FnDecl;

	// parse_generics, libsyntax/parser/parser.rs, line 3457
Generics:
	{Generics} (
	// The grammar allows for out-of-order lifetimes/generic params,
	// but that is solely to throw a warning about them being out of order.
	// Lifetimes are supposed to proceed type parameters
	LT tyParams=TyParams COMMA? GT)?;

	// parse_lifetime, libsyntax/parser/parser.rs, line 1566
Lifetime hidden():
	'\'' name=ID;

TyParams:
	{TyParams} (values+=TyParam => (COMMA values+=TyParam)*)?;

	// parse_ty_param, libsyntax/parser/parser.rs, line 3429
TyParam:
// parse_sized
// parse_optional_ty_param_bounds
	dynamicSized?=TYPE_KW? name=ID bounds=TyParamBounds;

	// parse_optional_ty_param_bounds, libsyntax/parser/parser.rs, line 3380
TyParamBounds:
	{TyParamBounds} COLON bounds+=TyParamBound (PLUS bounds+=TyParamBound);

TyParamBound:
	StaticRegionTyParamBound | OtherRegionTyParamBound;

StaticRegionTyParamBound:
	{StaticRegionTyParamBound} "'static";

OtherRegionTyParamBound:
	Lifetime;

	// parse_fn_decl, libsyntax/parser/parser.rs, line 3533
FnDecl:
// parse_fn_args (non-variadic, named) (TODO Separate into variadic/non-variadic grammar, or treat as error?)
	LPAREN args+=NamedArg (COMMA args+=NamedArg)* RPAREN
	// parse_ret_ty (TODO Separate into named/unnamed args, or treat as error?)
;

// parse_arg_general, libsyntax/parser/parser.rs, line 1342
NamedArg:
	{Arg} pat=Pat COLON ty=Ty;

Arg:
	(=> pat=Pat COLON)? ty=Ty;

	// parse_pat, libsyntax/parser/parser.rs, line 2764
Pat:
	{PatWild} '_' |
	{PatUniq} AT pat=Pat | // TODO This pattern is obsolete
	{PatOwned} TILDE pat=Pat | // TODO This pattern is obsolete
	{PatRegion} AND pat=Pat |
	{PatTup} LPAREN pats+=Pat (COMMA pats+=Pat) RPAREN |
	PatVec |
	LiteralMaybeMinus ({PatRange.start=current} => DOTDOT end=LiteralMaybeMinus | {PatLit.value=current});

	// parse_pat_vec_elements, libsyntax/parser/parser.rs, line 2639
PatVec:
	{PatVec} LBRACKET (DOTDOT after+=Pat+ |
	(before+=Pat COMMA)+ DOTDOT (after+=Pat (COMMA after+=Pat)*)?) RBRACKET;

	// parse_literal_maybe_minus, libsyntax/parser/parser.rs, line 1441
LiteralMaybeMinus:
	{UnNeg} MINUS lit=Lit |
	{ExprLit} lit=Lit;

// parse_ty, libsyntax/parser/parser.rs, line 1195
Ty:
	// Match "()", "(ty)", and "(ty,..)"
	LPAREN (
		{TyNil} RPAREN |
		Ty (
			{TyParen.ty=current} RPAREN |
			{TyTup.tys+=current} COMMA (tys+=Ty =>(COMMA tys+=Ty)* COMMA?)? RPAREN
		)		
	) |
	{TyBox} AT ty=Ty |
	{TyUniq} TILDE /* Can match a string here for now */ ty=Ty |
	{TyPtr} STAR mutTy=MutTy |
	{TyVec} LBRACKET ty=Ty (COMMA DOTDOT suffix=Expr)? RBRACKET |
	TyRptr |
	TyBareFn |
	TyClosure |
	{TyTypeof} "typeof" LPAREN expr=Expr RPAREN |
	TyProc |
	TyPath |
	{TyInfer} '_';

	// parse_mt, libsytnax/parser/parser.rs, line 1141
MutTy:
// parse_mutability
// parse_ty
	mutbl=Mutability ty=Ty;

Mutability:
	{MutMutable} MUT_KW | {MutImmutable} CONST_KW?;

	// parse_expr, libsyntax/parser/parser.rs, line 2606
// Assumes UNRESTRICTED restriction in parser
Expr:
	AssignExpr;

	// parse_expr with RESTRICT_STMT_EXPR
Expr_RestrictStmt:
	AssignExpr_RestrictStmt;

	// parse_assign_expr, libsyntax/parser/parser.rs, line 2383
AssignExpr:
	ExprBinaryPrecedence0 => ({ExprAssign.lhs=current} EQ rhs=Expr | {ExprBreak.lhs=current} DARROW rhs=Expr)?;

	// parse_expr with RESTRICT_STMT_EXPR set as condition
AssignExpr_RestrictStmt:
	ExprBinaryPrecedence0_RestrictStmt => ({ExprAssign.lhs=current} => EQ rhs=ExprStmt |
	// TODO Compound assignment
	{ExprBreak.lhs=current} => DARROW rhs=ExprStmt)?;

	// operator_prec, libsyntax/ast_util.rs, line 319
BinOpEq hidden():
	(BinOpPrec06 | BinOpPrec07 | BinOpPrec08 | BinOpPrec09 | BinOpPrec10 | BinOpPrec11) EQ;

BinOpPrec11:
	{BiDiv} SLASH | {BiMul} STAR | {BiRem} PERCENT;

BinOpPrec10:
	{BiAdd} PLUS | {BiSub} MINUS;
	// "<<" and ">>" are divided into individual tokens to prevent nested generic parameters from being consumed together
BinOpPrec09 hidden():
	({BiShl} LT => LT | {BiShr} GT => GT);

BinOpPrec08:
	{BiBitAnd} AND;

BinOpPrec07:
	{BiBitXor} CARET;

BinOpPrec06:
	{BiBitOr} OR;

BinOpPrec04:
	{BiLt} LT | {BiLe} LE | {BiGt} GT | {BiGe} GE;

BinOpPrec03:
	{BiEq} EQEQ | {BiNe} NE;

BinOpPrec02 hidden():
	{BiAnd} ANDAND;

BinOpPrec01 hidden():
	{BiOr} OROR;

	// parse_binops, libsyntax/parser/parser.rs, line 2328
// min_prec = 0
ExprBinaryPrecedence0:
	ExprBinaryPrecedence1 => ({ExprBinary.lhs=current} op=BinOpPrec01 rhs=ExprBinaryPrecedence1)?;

ExprBinaryPrecedence1:
	ExprBinaryPrecedence2 => ({ExprBinary.lhs=current} op=BinOpPrec02 rhs=ExprBinaryPrecedence2)?;

ExprBinaryPrecedence2:
	ExprBinaryPrecedence3 => ({ExprBinary.lhs=current} op=BinOpPrec03 rhs=ExprBinaryPrecedence3)?;

ExprBinaryPrecedence0_RestrictStmt:
	ExprBinaryPrecedence1_RestrictStmt => ({ExprBinary.lhs=current} op=BinOpPrec01 rhs=ExprStmt)?;

ExprBinaryPrecedence3:
	ExprBinaryPrecedence4 => ({ExprBinary.lhs=current} op=BinOpPrec04 rhs=ExprBinaryPrecedence4)?;

ExprBinaryPrecedence4:
	ExprBinaryPrecedence6 => ({ExprBinary.lhs=current} op=BinOpPrec06 rhs=ExprBinaryPrecedence6)?;

ExprBinaryPrecedence6:
	ExprBinaryPrecedence7 => ({ExprBinary.lhs=current} op=BinOpPrec07 rhs=ExprBinaryPrecedence7)?;

ExprBinaryPrecedence7:
	ExprBinaryPrecedence8 => ({ExprBinary.lhs=current} op=BinOpPrec08 rhs=ExprBinaryPrecedence8)?;

ExprBinaryPrecedence8:
	ExprBinaryPrecedence9 => ({ExprBinary.lhs=current} op=BinOpPrec09 rhs=ExprBinaryPrecedence9)?;

ExprBinaryPrecedence9:
	ExprBinaryPrecedence10 => ({ExprBinary.lhs=current} op=BinOpPrec10 rhs=ExprBinaryPrecedence10)?;

ExprBinaryPrecedence10:
	ExprUnary => ({ExprBinary.lhs=current} op=BinOpPrec11 rhs=ExprUnary)?;

ExprBinaryPrecedence1_RestrictStmt:
	ExprBinaryPrecedence2_RestrictStmt => ({ExprBinary.lhs=current} op=BinOpPrec02 rhs=ExprStmt)?;

ExprBinaryPrecedence2_RestrictStmt:
	ExprBinaryPrecedence3_RestrictStmt => ({ExprBinary.lhs=current} op=BinOpPrec03 rhs=ExprStmt)?;

ExprBinaryPrecedence3_RestrictStmt:
	ExprBinaryPrecedence4_RestrictStmt => ({ExprBinary.lhs=current} op=BinOpPrec04 rhs=ExprStmt)?;

ExprBinaryPrecedence4_RestrictStmt:
	ExprBinaryPrecedence6_RestrictStmt => ({ExprBinary.lhs=current} op=BinOpPrec06 rhs=ExprStmt)?;

ExprBinaryPrecedence6_RestrictStmt:
	ExprBinaryPrecedence7_RestrictStmt => ({ExprBinary.lhs=current} op=BinOpPrec07 rhs=ExprStmt)?;

ExprBinaryPrecedence7_RestrictStmt:
	ExprBinaryPrecedence8_RestrictStmt => ({ExprBinary.lhs=current} op=BinOpPrec08 rhs=ExprStmt)?;

ExprBinaryPrecedence8_RestrictStmt:
	ExprBinaryPrecedence9_RestrictStmt => ({ExprBinary.lhs=current} op=BinOpPrec09 rhs=ExprStmt)?;

ExprBinaryPrecedence9_RestrictStmt:
	ExprBinaryPrecedence10_RestrictStmt => ({ExprBinary.lhs=current} op=BinOpPrec10 rhs=ExprStmt)?;

ExprBinaryPrecedence10_RestrictStmt:
	ExprStmt /* | ExprUnary */ => ({ExprBinary.lhs=current} op=BinOpPrec11 rhs=ExprStmt)?;

ExprStmt:
	ExprIf | ExprMatch | ExprBlock | ExprWhile | ExprFor;

	// parse_prefix_expr, libsyntax/parser/parser.rs, line 2210
ExprUnary:
	{UnNot} NOT expr=ExprUnary | {UnNeg} MINUS expr=ExprUnary | {UnDeref} STAR expr=ExprUnary |
	// TODO Parser includes a hack here to parse &[] vector expressions
	{ExprAddrOf} AND lifetime=Lifetime? mutbl=Mutability expr=ExprUnary |
	// TODO Parser includes a hack here to parse @[] vector expressions
	{UnBox} AT expr=ExprUnary |
	// TODO Parser includes a hack here to parse @[] vector expressions
	{UnUniq} TILDE expr=ExprUnary | {ExprBox} BOX_KW LPAREN place=Expr? RPAREN expr=ExprUnary | DotOrCallExpr;

	// parse_dot_or_call_expr, libsyntax/parser/parser.rs, line 1934
DotOrCallExpr:
	ExprBottom =>(
		// Dropped ExprMethodCall from here, although syn. pred. would have fixed it.
		{ExprField.expr=current} DOT method=ID (MOD_SEP genericValues=GenericValues)? |
		{ExprCall.expr=current} LPAREN (args+=Expr (COMMA args+=Expr)*)? RPAREN
		{ExprIndex.expr=current} LBRACKET index=Expr RBRACKET
	)*;

// parse_bottom_expr, libsyntax/parser/parser.rs, line 1716
ExprBottom:
// See maybe_whole_expr! macro, libsyntax/parser/parser.rs, line 131
	LPAREN expr=Expr ({ExprParen.exprs=current} RPAREN | {ExprTup.exprs+=current} COMMA => (exprs+=Expr COMMA)* exprs+=Expr? RPAREN) |
	ExprBlock |
	ExprFnBlock |
	ExprProc |
	ExprSelf |
	ExprIf |
	ExprFor |
	ExprWhile |
	Lifetime COLON ({ExprForWithLifetime.lifetime=current} for=ExprFor | {ExprLoopWithLifetime.lifetime=current}
	loop=ExprLoop) |
	ExprLoop |
	ExprContinue |
	ExprMatch |
	UnsafeBlock |
	{ExprVec} LBRACKET (exprs+=Expr ((COMMA exprs+=Expr)* |
	{ExprRepeat.exprs=current} => (COMMA DOTDOT) count=Expr))? RBRACKET |
	ExprRet |
	ExprBreak |
	path=ExprPath (
		{MacInvocTT.path=current} NOT (LBRACE tts+=TT* RBRACE | LPAREN tts+=TT* RPAREN | LBRACKET tts+=TT* RBRACKET)
		// TODO Struct creation
	)? |
	{ExprLit} expr=Lit;

ExprBlock:
	{ExprBlock} LBRACE /* TODO block contents */ RBRACE;

	// parse_lambda_expr, libsyntax/parser/parser.rs, line 2468
ExprFnBlock:
	decl=FnBlockDecl body=Expr;

	// parse_fn_block_decl, libsyntax/parser/parser.rs, line 3713
FnBlockDecl:
	{FnBlockDecl} (OROR | OR (args+=FnBlockArg (COMMA args+=FnBlockArg)*)?) OR returnTy=RetTy?;

	// parse_fn_block_arg, libsyntax/parser/parser.rs, line 1372
FnBlockArg:
	pat=Pat (COLON ty=Ty)?;

ExprProc:
	decl=ProcDecl body=Expr;

	// parse_proc_decl, libsyntax/parser/parser.rs, line 3745
ProcDecl:
	{FnBlockDecl} PROC_KW LPAREN (args+=FnBlockArg (COMMA args+=FnBlockArg)*)? RPAREN (RARROW returnTy=Ty)?;

ExprSelf:
	{ExprPath} SELF_KW // TODO Parser parses further path here
;

// parse_if_expr, libsyntax/parser/parser.rs, line 2424
ExprIf:
	IF_KW cond=Expr thn=ExprBlock (ELSE_KW els=ExprBlock)?;

	// parse_for_expr, libsyntax/parser/parser.rs, line 2505
ExprFor:
	{ExprForLoop} FOR_KW pat=Pat IN_KW expr=Expr loopBlock=ExprBlock;

	// parse_while_expr, libsyntax/parser/parser.rs, line 2518
ExprWhile:
	WHILE_KW cond=Expr body=ExprBlock;

	// parse_loop_expr, libsyntax/parser/parser.rs, line 2526
ExprLoop:
	LOOP_KW ({ExprLoop} name=ID? body=ExprBlock /* TODO Hide obsolete syntax for now | {ExprAgain} lifetime=Lifetime? */);

ExprContinue:
	{ExprAgain} CONTINUE_KW lifetime=Lifetime;

	// parse_match_expr, libsyntax/parser/parser.rs, line 2568
ExprMatch:
	MATCH_KW discriminant=Expr LBRACE (=> arms+=HeadArm* arms+=TailArm)? RBRACE;

Arm:
	HeadArm | TailArm;

HeadArm:
// parse_outer_attributes
// parse_pats
	attributes=OuterAttributes? pats=Pats (IF_KW guard=Expr)? FAT_ARROW (=> expr=ExprBlock | expr=Expr_RestrictStmt COMMA);

TailArm:
// TODO Check that this correct?
	attributes=OuterAttributes? pats=Pats (IF_KW guard=Expr)? FAT_ARROW (=> expr=ExprBlock | expr=Expr_RestrictStmt);

	// parse_pats, libsyntax/parser/parser.rs, line 2630
Pats:
	pats+=Pat (OR pats+=Pat)*;

UnsafeBlock:
	UNSAFE_KW block=ExprBlock;

ExprRet:
// can_begin_expr
	{ExprRet} RETURN_KW => expr=Expr?;

ExprBreak:
	{ExprBreak} BREAK_KW lifetime=Lifetime?;

ExprPath:
	path=PathWithLifetimeAndTypesWithColons;
	
	// parse_borrowed_pointee, libsyntax/parser/parser.rs, line 1313
TyRptr:
	AND lifetime=Lifetime? mutTy=MutTy;

	// parse_ty_bare_fn, libsyntax/parser/parser.rs, line 890
/*
  [unsafe] [extern "ABI"] fn <'lt> (S) -> T
   ^~~~^           ^~~~^     ^~~~^ ^~^    ^
     |               |         |    |     |
     |               |         |    |   Return type
     |               |         |  Argument types
     |               |     Lifetimes
     |              ABI
  Function Style
*/
TyBareFn:
	fnStyle=FnStyle (EXTERN_KW abi=STRING?)? FN_KW decl=FnDecl;

	// parse_unsafety, libsyntax/parser/parser.rs, line 1026
FnStyle:
	unsafeFn?=UNSAFE_KW // AST implements this as UnsafeFn and NormalFn
;

// parse_ty_closure, libsyntax/parse/parser.rs, line 969
/*
  [unsafe] [once] <'lt> |S| [:Bounds] -> T
  ^~~~~~~^ ^~~~~^ ^~~~^  ^  ^~~~~~~~^    ^
    |        |      |    |      |        |
    |        |      |    |      |      Return type
    |        |      |    |  Closure bounds
    |        |      |  Argument types
    |        |    Lifetimes
    |     Once-ness (a.k.a., affine)
  Function Style
*/
TyClosure:
	fnStyle=FnStyle onceness=Onceness lifetimes=Lifetimes? (OROR | OR args+=Arg (COMMA args+=Arg)* OR)
	bounds=TyParamBounds retTy=RetTy;

Onceness:
	once?=ONCE_KW;

	// parse_lifetimes, libsyntax/parser/parser.rs, line 1586
Lifetimes:
	LT lifetimes+=Lifetime => (COMMA lifetimes+=Lifetime)* COMMA? GT;

	// parse_ret_ty, libsyntax/parse/parser.rs
RetTy:
	{RetTy} RARROW ty=Ty;

	// parse_proc_type, libsyntax/parser/parser.rs, line 928
/*
  proc <'lt> (S) [:Bounds] -> T
  ^~~^ ^~~~^  ^  ^~~~~~~~^    ^
   |     |    |      |        |
   |     |    |      |      Return type
   |     |    |    Bounds
   |     |  Argument types
   |   Lifetimes
  the `proc` keyword
*/
TyProc:
	PROC_KW lifetimes=Lifetimes? /* not named, not variadic */ fnArgs=FnArgs bounds=TyParamBounds retTy=RetTy;

	// parse_fn_args, libsyntax/parser/parser.rs, line 3485
FnArgs:
	LPAREN args+=Arg => (COMMA args+=Arg)* COMMA? RPAREN;

// parse_path, libsyntax/parser/parser.rs, line 1463
TyPath:
	path=PathWithLifetimesTypesAndBounds;

PathWithLifetimesTypesAndBounds:
	// TODO Is this missing the trailing generic params?
	// TODO Cross-reference modules
	global?=MOD_SEP segments+=PathSegment =>(MOD_SEP segments+=PathSegment)* (bounds=TyParamBounds genericValues=GenericValues?)?;

PathWithLifetimeAndTypesWithColons:
	// TODO Cross-reference modules
	global?=MOD_SEP segments+=ExprPathSegment (MOD_SEP segments+=ExprPathSegment)*;

PathSegment:
	name=ID genericValues=GenericValues?;
	
ExprPathSegment:
	name=ID genericValues=ExprGenericValues?;

	// parse_generic_values_after_lt, libsyntax/parser/parser.rs, line 
GenericValues:
	LT (lifetimes+=Lifetime => (COMMA lifetimes+=Lifetime)* COMMA)? tys+=Ty => (COMMA tys+=Ty)* COMMA? GT;

	// parse_generic_values_after_lt, libsyntax/parser/parser.rs, line 
ExprGenericValues:
	"::<" (lifetimes+=Lifetime => (COMMA lifetimes+=Lifetime)* COMMA)? tys+=Ty => (COMMA tys+=Ty)* COMMA? GT;


	// parse_mod_items, libsyntax/parser/parser.rs, line 4059
/*Mod:
	// parse_items_and_view_items
;

ItemsAndViewItems:
	
;*/

// parse_token_tree, libsyntax/parser/parser.rs, line 2043
TT:
	// TODO Invoke maybe_whole!
	{TTDelim} LBRACKET tts+=TT* RBRACKET |
	{TTDelim} LPAREN tts+=TT* RPAREN |
	{TTDelim} LBRACE tts+=TT* RBRACE |
	NonDelimTTToken
;

// parse_token_tree::parse_non_delim_tt_tok, libsyntax/parser/parser.rs, line 2043
NonDelimTTToken:
	// TODO Invoke maybe_whole!
	DOLLAR ({TTSeq} LPAREN tts+=TT* RPAREN (separator=(NOT_MACRO_TOKEN | DOLLAR)? (zerok?=STAR | PLUS)) | {TTNonterminal} name=ID) |
	// parse_token_tree::parse_any_tt_tok, libsyntax/parser/parser.rs, line 2099
	{TTTok} token=(NOT_MACRO_TOKEN | STAR | PLUS)
;

terminal AS_KW: "as";
terminal BREAK_KW: "break";
terminal CONST_KW: "const";
terminal CRATE_KW: "crate";
terminal ELSE_KW: "else";
terminal ENUM_KW: "enum";
terminal EXTERN_KW: "extern";
terminal FALSE_KW: "false";
terminal FN_KW: "fn";
terminal FOR_KW: "for";
terminal IF_KW: "if";
terminal IMPL_KW: "impl";
terminal IN_KW: "in";
terminal LET_KW: "let";
terminal LOOP_KW: "loop";
terminal MATCH_KW: "match";
terminal MOD_KW: "mod";
terminal MUT_KW: "mut";
terminal ONCE_KW: "once";
terminal PUB_KW: "pub";
terminal REF_KW: "ref";
terminal RETURN_KW: "return";
terminal STATIC_KW: "static";
terminal SELF_KW: "self";
terminal STRUCT_KW: "struct";
terminal SUPER_KW: "super";
terminal TRUE_KW: "true";
terminal TRAIT_KW: "trait";
terminal TYPE_KW: "type";
terminal UNSAFE_KW: "unsafe";
terminal USE_KW: "use";
terminal VIRTUAL_KW: "virtual";
terminal WHILE_KW: "while";
terminal CONTINUE_KW: "continue";
terminal PROC_KW: "proc";
terminal BOX_KW: "box";

/*terminal KEYWORD:
	AS_KW |
	BREAK_KW |
	CONST_KW |
	CRATE_KW |
	ELSE_KW |
	ENUM_KW |
	EXTERN_KW |
	FALSE_KW |
	FN_KW |
	FOR_KW |
	IF_KW |
	IMPL_KW |
	IN_KW |
	LET_KW |
	LOOP_KW |
	MATCH_KW |
	MOD_KW |
	MUT_KW |
	ONCE_KW |
	PUB_KW |
	REF_KW |
	RETURN_KW |
	STATIC_KW |
	SELF_KW |
	STRUCT_KW |
	SUPER_KW |
	TRUE_KW |
	TRAIT_KW |
	TYPE_KW |
	UNSAFE_KW |
	USE_KW |
	VIRTUAL_KW |
	WHILE_KW |
	CONTINUE_KW |
	PROC_KW |
	BOX_KW;*/

terminal EQ: '=';
terminal LT: '<';
terminal LE: '<=';
terminal EQEQ: '==';
terminal NE: '!=';
terminal GE: '>=';
terminal GT: '>';
terminal AND: '&';
terminal OR: '|';
terminal CARET: '^';
terminal ANDAND: '&&';
terminal OROR: '||';
terminal NOT: '!';
terminal TILDE: '~';
terminal PLUS: '+';
terminal MINUS: '-';
terminal STAR: '*';
terminal SLASH: '/';
terminal PERCENT: '%';
terminal SHL: "<<";
terminal SHR: ">>";

// Structural
terminal AT: '@';
terminal DOT: '.';
terminal DOTDOT: '..';
terminal DOTDOTDOT: '...';
terminal COMMA: ',';
terminal SEMI: ';';
terminal COLON: ':';
terminal MOD_SEP: '::';
terminal RARROW: '->';
terminal LARROW: '<-';
terminal DARROW: '<->';
terminal FAT_ARROW: '=>';
terminal LPAREN: '(';
terminal RPAREN: ')';
terminal LBRACKET: '[';
terminal RBRACKET: ']';
terminal LBRACE: '{';
terminal RBRACE: '}';
terminal POUND: '#';
terminal DOLLAR: '$';

terminal CHAR:
	"'" (('\\' ('\\' | 'n' | 'r' | 't' | '0' | "'")) | UNICODE_CHAR | !('\\' | "'")) "'";

terminal STRING:
	'"' (('\\' ('\\' | 'n' | 'r' | 't' | '0' | '"' | '\n')) | UNICODE_CHAR | !('\\' | '"'))* '"';

terminal fragment UNICODE_CHAR:
	UTF8_CHAR | UTF16_CHAR | UTF32_CHAR;

terminal fragment UTF8_CHAR:
	'\\x' HEX_DIGIT HEX_DIGIT;

terminal fragment UTF16_CHAR:
	'\\u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

terminal fragment UTF32_CHAR:
	'\\U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

terminal fragment SIGNED_INT_TYPE:
	I | I8 | I16 | I32 | I64;

terminal fragment I:
	"i";

terminal fragment I8:
	"i8";

terminal fragment I16:
	"i16";

terminal fragment I32:
	"i32";

terminal fragment I64:
	"i64";

terminal fragment UNSIGNED_INT_TYPE:
	U | U8 | U16 | U32 | U64;

terminal fragment U:
	"u";

terminal fragment U8:
	"u8";

terminal fragment U16:
	"u16";

terminal fragment U32:
	"u32";

terminal fragment U64:
	"u64";

terminal fragment FLOAT_SUFFIX:
	F32 | F64;

terminal fragment F32:
	"f32";

terminal fragment F64:
	"f64";

	// Floating point literal
terminal FLOAT_UNSUFFIXED:
	DEC_DIGIT (DEC_DIGIT | '_')* ('.' (DEC_DIGIT | '_')+) (('E' | 'e') ('+' | '-')? (DEC_DIGIT | '_')+)?;

terminal FLOAT:
	FLOAT_UNSUFFIXED FLOAT_SUFFIX;

	// Integer literal
terminal INT_UNSUFFIXED:
	(DEC_INT_LIT | BIN_INT_LIT | OCT_INT_LIT | HEX_INT_LIT);

terminal INT:
	INT_UNSUFFIXED SIGNED_INT_TYPE;

terminal UINT:
	INT_UNSUFFIXED UNSIGNED_INT_TYPE;

	// Decimal (base 10) integer
terminal fragment DEC_INT_LIT:
	DEC_DIGIT (DEC_DIGIT | '_')*;

	// Binary (base 2) integer
terminal fragment BIN_INT_LIT:
	"0b" ('0' | '1' | '_')+;

	// Octal (base 8) integer
terminal fragment OCT_INT_LIT:
	"0o" (OCT_DIGIT | '_')+;

	// Hex (base 16) integer
terminal fragment HEX_INT_LIT:
	"0x" (HEX_DIGIT | '_')+;

terminal fragment OCT_DIGIT:
	'0'..'7';

terminal fragment DEC_DIGIT:
	'0'..'9';

terminal fragment HEX_DIGIT:
	'0'..'9' | 'a'..'f' | 'A'..'F';

	// terminal fragment NON_SPECIAL_CHAR: !('"' | '\'' | '\\' | 'n' | 'r' | 't' | '0');

terminal ID:
	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;
	
terminal NOT_MACRO_TOKEN:
	!(DOLLAR | STAR | PLUS)
;