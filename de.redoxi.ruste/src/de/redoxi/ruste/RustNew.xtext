grammar de.redoxi.ruste.Rust hidden(WS, SL_COMMENT, ML_COMMENT)

generate rust "http://www.redoxi.de/ruste/grammar/Rust"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// parse_crate_mod, libsyntax/parser/parser.rs, line 5087
Crate:
	module=Mod;

InnerAttributes:
	attributes+=InnerAttribute+;

InnerAttribute:
	=> (POUND NOT) LBRACKET metaItem=MetaItem RBRACKET;

OuterAttributes:
	attributes+=OuterAttribute+;

	// parse_attribute, libsyntax/parser/attr.rs, line 62
OuterAttribute:
	POUND LBRACKET metaItem=MetaItem RBRACKET;

	// parse_meta_item, libsyntax/parser/attr.rs, line 154
MetaItem:
	name=ID (EQ value=Lit | LPAREN value=MetaList RPAREN)?;

	// parse_lit, libsyntax/parser/parser.rs, line 1426
Lit hidden():
	{BoolLit} value=("true" | "false") |
	// lit_from_token, libsyntax/parser/parser.rs, line 1402
	{LitChar} value=CHAR | {LitInt} value=INT | {LitUint} value=UINT | {LitIntSuffixed} value=INT_UNSUFFIXED | {LitFloat}
	value=FLOAT | {LitFloatUnsuffixed} value=FLOAT_UNSUFFIXED | {LitString} value=STRING |
	// TODO {LitRawString}
	{LitUnit} LPAREN RPAREN;

	// parse_meta_seq, libsyntax/parser/attr.rs, line 196
MetaList:
	metaItems+=MetaItem (COMMA metaItems+=MetaItem)*;

ViewItem:
// parse_item_or_view_item, libsyntax/parser/parser.rs, line 4546
	ViewItemUse SEMI | ViewExternItem;

ViewItemUse:
// parse_item_or_view_item, libsyntax/parser/parser.rs, line 4818
// TODO Alias?
	"use" path=ViewPath;

	// parse_view_paths, libsyntax/parser/parser.rs, line 4951
ViewPath hidden():
	// parse_view_paths, libsyntax/parser/parser.rs, line 4848
	{ViewPathSimple} name=ID EQ path=Path |
	Path (
		{ViewPathSimple.path=current} |
		// parse_view_paths, libsyntax/parser/parser.rs, line 4875
		{ViewPathGlob.path=current} (MOD_SEP STAR) |
		// parse_view_paths, libsyntax/parser/parser.rs, line 4875
		{ViewPathList.path=current} (MOD_SEP LBRACE) WS? ids+=ID (WS? COMMA WS? ids+=ID)* WS? RBRACE
	);

	// TODO NonGlobalPath?
	// TODO Use TypePath or ExprPath as appropriate
Path:
	segments+=ID (MOD_SEP segments+=ID)*;

ViewExternItem:
	"extern" (
	// parse_item_extern_crate, libsyntax/parser/parser.rs, line 4318
	{ViewItemExternCrate} "crate" name=ID (EQ path=STRING)? SEMI |
	{ViewItemExternFn} abi=STRING? fn=FnItem |
	// parse_item_foreign_mod, libsyntax/parser/parser.rs, line 4362
	{ItemForeignMod} abi=STRING? LBRACE innerAttrs=InnerAttributes? items+=ForeignItem* RBRACE);

	// parse_foreign_item, libsyntax/parser/parser.rs, line 4718
ForeignItem:
	visibility=Visibility node=(ItemForeignStatic | ItemForeignFn)
	// TODO Fall-through to parse_macro_use_or_failure here
;

// parse_item_foreign_static, libsyntax/parser/parser.rs, line 4257
ItemForeignStatic:
	{ForeignItemStatic} "static" mutbl=Mutability name=ID COLON ty=Ty SEMI;

	// parse_item_foreign_fn, libsyntax/parser/parser.rs, line 4234
ItemForeignFn:
	fnStyle=FnStyle name=ID generics=Generics decl=FnDecl;

	// parse_visibility, libsyntax/parser/parser.rs, line 4035
Visibility:
	{Visibility} public?="pub"?;

Item:
	attrs=OuterAttributes? (vis=Visibility node=(ItemStatic | FnItem | UnsafeFnItem | ItemMod | ItemType | ItemEnum | ItemTrait | ItemImpl) |
	node=ViewItem);

	// parse_item_const, libsyntax/parser/parser.rs, line 4114
ItemStatic:
	"static" name=ID COLON ty=Ty EQ expr=Expr /* commit_expr_expecting(expr, SEMI) */ SEMI;

	// parse_item_fn, libsyntax/parser/parser.rs, line 3791
FnItem:
// parse_fn_header
// parse_fn_decl
// parse_inner_attrs_and_block
	"fn" name=ID generics=Generics decl=FnDecl block=Block;

UnsafeFnItem:
	"unsafe" fn=FnItem;

	// parse_item_mod, libsyntax/parser/parser.rs, line 4126
ItemMod:
	"mod" name=ID (external?=SEMI | LBRACE module=Mod RBRACE);

	// parse_item_type, libsyntax/parser/parser.rs, line 4387
ItemType:
	{ItemTy} "type" name=ID generics=Generics EQ ty=Ty SEMI;

	// parse_item_enum, libsyntax/parser/parser.rs, line 4478
ItemEnum:
	"enum" name=ID generics=Generics
	// parse_enum_def
	LBRACE enumDefinition=EnumDef RBRACE;

// parse_item_trait, libsyntax/parser/parser.rs, line 3834
ItemTrait:
	"trait" name=ID generics=Generics sized=ForSized traits=TraitRefList meths=TraitMethods
;

// parse_item_impl, libsyntax/parser/parser.rs, line 3855
ItemImpl:
	generics=Generics /* TODO special rule for LPAREN here */
	(optTrait=ID "for")? // TODO crossreference trait
	ty=Ty // TODO crossreference struct
	LBRACE
	atts=InnerAttributes?
	meths+=Method*
	RBRACE
;

// parse_method, libsyntax/parser/parser.rs, line 3799
Method:
	attrs=OuterAttributes? vis=Visibility fnStyle=FnStyle name=ID generics=Generics decl=FnDeclWithSelf_ArgGeneral body=Block
;

// parse_trait_ref_list, libsyntax/parser/parser.rs, line 3916
TraitRefList:
	{TraitRefList} (COLON traits+=TraitRef (PLUS traits+=TraitRef)*)?;

// parse_trait_ref, libsyntax/parser/parser.rs, line 3809
TraitRef:
	path=PathWithLifetimeAndTypesWithoutColons;

// parse_for_sized, libsyntax/parser/parser.rs, line 4045
ForSized:
	({DynSize} "for" "type" | {StaticSize})
;

// parse_trait_methods, libsyntax/parser/parser.rs, line 1067
TraitMethods:
	{TraitMethods} LBRACE methods+=TraitMethod* RBRACE
;

TraitMethod:
	attrs=OuterAttributes? vis=Visibility fnStyle=FnStyle name=ID generics=Generics decl=FnDeclWithSelf_ArgGeneral (required?=SEMI | body=Block)
;

// parse_fn_decl_with_self, libsyntax/parser/parser.rs, line 3563
FnDeclWithSelf_ArgGeneral:
	LPAREN self=FnDeclWithSelf_Self (COMMA args+=ArgGeneral)* RPAREN
;

FnDeclWithSelf_Self:
	{SelfRegion} AND lifetime=LIFETIME? mutbl=Mutability "self" |
	TILDE ({SelfUniq} "self" | {SelfStatic}) |
	STAR ({SelfValue} mutbl=Mutability "self") |	// ERROR
	{SelfValue} "self" |
	Mutability_Required (
		{SelfValue.mutbl=current} "self" |
		{SelfUniq.mutbl=current} TILDE "self"
	) |
	{SelfStatic}
;

	// parse_enum_def, libsyntax/parser/parser.rs, line 
EnumDef:
	{EnumDef} (variants+=Variant (COMMA variants+=Variant)* COMMA?)?;

Variant:
	Visibility ({StructVariantKind.vis=current} def=StructDef | {TupleVariantKind.vis=current} (LPAREN (tys+=Ty (COMMA
	tys+=Ty)*)? /* ERROR if empty list given - nullary enums are written without '(' ')' */ RPAREN | EQ disrExpr=Expr));

	// parse_struct_def, libsyntax/parser/parser.rs, line 4398
StructDef:
	{StructDef} LBRACE (fields+=StructDeclField (COMMA fields+=StructDeclField)* COMMA?)? RBRACE;

	// parse_struct_decl_field, libsyntax/parser/parser.rs, line 4023
StructDeclField:
// parse_single_struct_field
	{NamedField} attrs=OuterAttributes? name=ID COLON /* parse_ty(false) */ ty=Ty;

	// parse_generics, libsyntax/parser/parser.rs, line 3457
Generics:
	{Generics} (
	// The grammar allows for out-of-order lifetimes/generic params,
	// but that is solely to throw a warning about them being out of order.
	// Lifetimes are supposed to proceed type parameters
	LT tyParams=TyParams COMMA? GT)?;

TyParams:
	{TyParams} (values+=TyParam => (COMMA values+=TyParam)*)?;

	// parse_ty_param, libsyntax/parser/parser.rs, line 3429
TyParam:
// parse_sized
// parse_optional_ty_param_bounds
	lifetime=LIFETIME | dynamicSized?="type"? name=ID bounds=TyParamBounds?;

	// parse_optional_ty_param_bounds, libsyntax/parser/parser.rs, line 3380
TyParamBounds:
	{TyParamBounds} COLON bounds+=TyParamBound (PLUS bounds+=TyParamBound);

TyParamBound:
	StaticRegionTyParamBound | OtherRegionTyParamBound;

StaticRegionTyParamBound:
	{StaticRegionTyParamBound} "'static";

OtherRegionTyParamBound:
	lifetime=LIFETIME;

	// parse_fn_decl, libsyntax/parser/parser.rs, line 3533
FnDecl:
	{FnDecl}
	// parse_fn_args (non-variadic, named) (TODO Separate into variadic/non-variadic grammar, or treat as error?)
	LPAREN (args+=ArgGeneral (COMMA args+=ArgGeneral)*)? RPAREN
	// parse_ret_ty (TODO Separate into named/unnamed args, or treat as error?)
	retTy=RetTy?;

	// parse_arg_general, libsyntax/parser/parser.rs, line 1342
ArgGeneral:
	{Arg} pat=Pat COLON ty=Ty;

Arg:
	(=> pat=Pat COLON)? ty=Ty;

	// parse_pat, libsyntax/parser/parser.rs, line 2764
Pat:
	{PatWild} '_' | {PatUniq} AT pat=Pat | // TODO This pattern is obsolete
	{PatOwned} TILDE pat=Pat | // TODO This pattern is obsolete
	{PatRegion} AND pat=Pat | {PatTup} LPAREN pats+=Pat (COMMA pats+=Pat) RPAREN | PatVec | LiteralMaybeMinus
	({PatRange.start=current} => DOTDOT end=LiteralMaybeMinus | {PatLit.value=current}) | {PatUniq} "box" pat=PatIdent |
	{PatIdent} (mutbl=Mutability_Required name=ID) |
	{PatRef} "ref" mutbl=Mutability pat=PatIdent | 
	PathWithLifetimeAndTypesWithColons ({PatIdent.path=current} |
		{PatStruct.path=current} LBRACE fields=PatFields RBRACE |
		{PatEnum.path=current} LPAREN (wildcard=DOTDOT | wildcard=STAR | args+=Pat (COMMA args+=Pat)*)? RPAREN
	);

	// parse_pat_vec_elements, libsyntax/parser/parser.rs, line 2639
PatVec:
	{PatVec} LBRACKET (DOTDOT after+=Pat (COMMA after+=Pat)* | (before+=Pat COMMA)+ DOTDOT (after+=Pat (COMMA after+=Pat)*)?) RBRACKET;

	// parse_literal_maybe_minus, libsyntax/parser/parser.rs, line 1441
LiteralMaybeMinus:
	{UnNeg} MINUS lit=Lit | {ExprLit} lit=Lit;

// parse_pat_fields, libsyntax/parser/parser.rs, line 2701
PatFields:
	{PatFields} (wildcard?=(DOTDOT | STAR) | fields+=FieldPat (COMMA fields+=FieldPat)* tailingWildcard?=DOTDOT?)?
;

FieldPat:
	binding=Binding
;

Binding:
	({BindByRef} "ref" mut=Mutability | {BindByValue} mut=Mutability) name=ID /* TODO path here */ (COLON pat=Pat)?
;

	// parse_pat_ident, libsyntax/parser/parser.rs, line 3010
PatIdent:
// TODO parser allows NoTypesAllowed path here
	name=ID;

	// parse_ty, libsyntax/parser/parser.rs, line 1195
Ty:
// Match "()", "(ty)", and "(ty,..)"
	LPAREN ({TyNil} RPAREN | Ty ({TyParen.ty=current} RPAREN | {TyTup.tys+=current} COMMA (tys+=Ty => (COMMA tys+=Ty)*
	COMMA?)? RPAREN)) | {TyBox} AT ty=Ty | {TyUniq} TILDE /* Can match a string here for now */ ty=Ty | {TyPtr} STAR
	mutTy=MutTy | {TyVec} LBRACKET ty=Ty (COMMA DOTDOT suffix=Expr)? RBRACKET | TyRptr | TyBareFn | TyClosure | {TyTypeof}
	"typeof" LPAREN expr=Expr RPAREN | TyProc | TyPath | {TyInfer} '_';

	// parse_mt, libsytnax/parser/parser.rs, line 1141
MutTy:
// parse_mutability
// parse_ty
	mutbl=Mutability ty=Ty;

Mutability:
	{MutMutable} "mut" | {MutImmutable} "const"?;

Mutability_Required:
	{Mutability} "mut";

	// parse_expr, libsyntax/parser/parser.rs, line 2606
// Assumes UNRESTRICTED restriction in parser
Expr:
	AssignExpr;

	// parse_expr with RESTRICT_STMT_EXPR
Expr_RestrictStmt:
	AssignExpr_RestrictStmt;

	// parse_assign_expr, libsyntax/parser/parser.rs, line 2383
AssignExpr:
	ExprBinaryPrecedence0 => ({ExprAssign.lhs=current} EQ rhs=Expr | {ExprBreak.lhs=current} DARROW rhs=Expr)?;

	// parse_expr with RESTRICT_STMT_EXPR set as condition
AssignExpr_RestrictStmt:
	ExprBinaryPrecedence0_RestrictStmt => ({ExprAssign.lhs=current} => EQ rhs=ExprUnary_RestrictStmt |
	// TODO Compound assignment
	{ExprBreak.lhs=current} => DARROW rhs=ExprUnary_RestrictStmt)?;

	// operator_prec, libsyntax/ast_util.rs, line 319
BinOpEq hidden():
	(BinOpPrec06 | BinOpPrec07 | BinOpPrec08 | BinOpPrec09 | BinOpPrec10 | BinOpPrec11) EQ;

BinOpPrec11:
	{BiDiv} SLASH | {BiMul} STAR | {BiRem} PERCENT;

BinOpPrec10:
	{BiAdd} PLUS | {BiSub} MINUS;
	// "<<" and ">>" are divided into individual tokens to prevent nested generic parameters from being consumed together
BinOpPrec09 hidden():
	({BiShl} LT => LT | {BiShr} GT => GT);

BinOpPrec08:
	{BiBitAnd} AND;

BinOpPrec07:
	{BiBitXor} CARET;

BinOpPrec06:
	{BiBitOr} OR;

BinOpPrec04:
	{BiLt} LT | {BiLe} LE | {BiGt} GT | {BiGe} GE;

BinOpPrec03:
	{BiEq} EQEQ | {BiNe} NE;

BinOpPrec02 hidden():
	{BiAnd} ANDAND;

BinOpPrec01 hidden():
	{BiOr} OROR;

	// parse_binops, libsyntax/parser/parser.rs, line 2328
// min_prec = 0
ExprBinaryPrecedence0:
	ExprBinaryPrecedence1 ({ExprBinary.lhs=current} op=BinOpPrec01 rhs=ExprBinaryPrecedence0)?;

ExprBinaryPrecedence1:
	ExprBinaryPrecedence2 ({ExprBinary.lhs=current} op=BinOpPrec02 rhs=ExprBinaryPrecedence1)?;

ExprBinaryPrecedence2:
	ExprBinaryPrecedence3 ({ExprBinary.lhs=current} op=BinOpPrec03 rhs=ExprBinaryPrecedence2)?;

ExprBinaryPrecedence3:
	ExprBinaryPrecedence4 ({ExprBinary.lhs=current} op=BinOpPrec04 rhs=ExprBinaryPrecedence3)?;

ExprBinaryPrecedence4:
	ExprBinaryPrecedence6 ({ExprBinary.lhs=current} op=BinOpPrec06 rhs=ExprBinaryPrecedence4)?;

ExprBinaryPrecedence6:
	ExprBinaryPrecedence7 ({ExprBinary.lhs=current} op=BinOpPrec07 rhs=ExprBinaryPrecedence6)?;

ExprBinaryPrecedence7:
	ExprBinaryPrecedence8 ({ExprBinary.lhs=current} op=BinOpPrec08 rhs=ExprBinaryPrecedence7)?;

ExprBinaryPrecedence8:
	ExprBinaryPrecedence9 ({ExprBinary.lhs=current} op=BinOpPrec09 rhs=ExprBinaryPrecedence8)?;

ExprBinaryPrecedence9:
	ExprBinaryPrecedence10 ({ExprBinary.lhs=current} op=BinOpPrec10 rhs=ExprBinaryPrecedence9)?;

ExprBinaryPrecedence10:
	ExprUnary ({ExprBinary.lhs=current} op=BinOpPrec11 rhs=ExprBinaryPrecedence10)?;

ExprBinaryPrecedence0_RestrictStmt:
	ExprBinaryPrecedence1_RestrictStmt ({ExprBinary.lhs=current} op=BinOpPrec01
	rhs=ExprBinaryPrecedence0_RestrictStmt)?;

ExprBinaryPrecedence1_RestrictStmt:
	ExprBinaryPrecedence2_RestrictStmt ({ExprBinary.lhs=current} op=BinOpPrec02
	rhs=ExprBinaryPrecedence1_RestrictStmt)?;

ExprBinaryPrecedence2_RestrictStmt:
	ExprBinaryPrecedence3_RestrictStmt ({ExprBinary.lhs=current} op=BinOpPrec03
	rhs=ExprBinaryPrecedence2_RestrictStmt)?;

ExprBinaryPrecedence3_RestrictStmt:
	ExprBinaryPrecedence4_RestrictStmt ({ExprBinary.lhs=current} op=BinOpPrec04
	rhs=ExprBinaryPrecedence3_RestrictStmt)?;

ExprBinaryPrecedence4_RestrictStmt:
	ExprBinaryPrecedence6_RestrictStmt ({ExprBinary.lhs=current} op=BinOpPrec06
	rhs=ExprBinaryPrecedence4_RestrictStmt)?;

ExprBinaryPrecedence6_RestrictStmt:
	ExprBinaryPrecedence7_RestrictStmt ({ExprBinary.lhs=current} op=BinOpPrec07
	rhs=ExprBinaryPrecedence6_RestrictStmt)?;

ExprBinaryPrecedence7_RestrictStmt:
	ExprBinaryPrecedence8_RestrictStmt ({ExprBinary.lhs=current} op=BinOpPrec08
	rhs=ExprBinaryPrecedence7_RestrictStmt)?;

ExprBinaryPrecedence8_RestrictStmt:
	ExprBinaryPrecedence9_RestrictStmt ({ExprBinary.lhs=current} op=BinOpPrec09
	rhs=ExprBinaryPrecedence8_RestrictStmt)?;

ExprBinaryPrecedence9_RestrictStmt:
	ExprBinaryPrecedence10_RestrictStmt ({ExprBinary.lhs=current} op=BinOpPrec10
	rhs=ExprBinaryPrecedence9_RestrictStmt)?;

ExprBinaryPrecedence10_RestrictStmt:
	ExprUnary_RestrictStmt ({ExprBinary.lhs=current} op=BinOpPrec11 rhs=ExprBinaryPrecedence10_RestrictStmt)?;

ExprUnary_RestrictStmt:
// Match any expressions ending in a block, then the unary production
	=> Expr_NoSemi | ExprUnary /* TODO check parser */;
	
Expr_NoSemi:
	ExprIf | ExprMatch | ExprBlock | ExprWhile | ExprFor;
	
	// parse_prefix_expr, libsyntax/parser/parser.rs, line 2210
ExprUnary:
	{UnNot} NOT expr=ExprUnary | {UnNeg} MINUS expr=ExprUnary | {UnDeref} STAR expr=ExprUnary |
	// TODO Parser includes a hack here to parse &[] vector expressions
	{ExprAddrOf} AND lifetime=LIFETIME? mutbl=Mutability expr=ExprUnary |
	// TODO Parser includes a hack here to parse @[] vector expressions
	{UnBox} AT expr=ExprUnary |
	// TODO Parser includes a hack here to parse @[] vector expressions
	{UnUniq} TILDE expr=ExprUnary | {ExprBox} "box" LPAREN place=Expr? RPAREN expr=ExprUnary | DotOrCallExpr;

	// parse_dot_or_call_expr, libsyntax/parser/parser.rs, line 1934
DotOrCallExpr:
	// TODO Hack. Not sure if syntatic predicate needed here
	ExprBottom ops+=DotOrCallExprTail*;

DotOrCallExprTail:
	(ExprField | ExprCall | ExprIndex);

ExprField:
	DOT method=ID (MOD_SEP genericValues=GenericValues)?;

ExprCall:
	{ExprCall} LPAREN (args+=Expr (COMMA args+=Expr)*)? RPAREN;

ExprIndex:
	LBRACKET index=Expr RBRACKET;

	// parse_bottom_expr, libsyntax/parser/parser.rs, line 1716
ExprBottom:
// See maybe_whole_expr! macro, libsyntax/parser/parser.rs, line 131
	LPAREN expr=Expr ({ExprParen.exprs=current} RPAREN | {ExprTup.exprs+=current} COMMA => (exprs+=Expr COMMA)*
	exprs+=Expr? RPAREN) |
	ExprBlock |
	LambdaExpr |
	ExprProc |
	ExprSelf |
	ExprIf |
	ExprFor |
	ExprWhile |
	lifetime=LIFETIME COLON ({ExprForWithLifetime} for=ExprFor | {ExprLoopWithLifetime}
	loop=ExprLoop) |
	ExprLoop |
	ExprContinue |
	ExprMatch |
	UnsafeBlock |
	{ExprVec} LBRACKET (exprs+=Expr ((COMMA exprs+=Expr)* |
	{ExprRepeat.exprs=current} (COMMA DOTDOT) count=Expr))? RBRACKET |
	ExprRet |
	ExprBreak |
	path=ExprPath (
		{MacInvocTT.path=current} NOT (LBRACE tts+=TT* RBRACE | LPAREN tts+=TT* RPAREN | LBRACKET tts+=TT* RBRACKET) |
		{ExprStruct.path=current} LBRACE (fields+=Field =>(COMMA fields+=Field)* COMMA?)? (DOTDOT base=Expr)? RBRACE)? |
	{ExprLit} expr=Lit;

	// parse_field, libsyntax/parser/parser.rs, line 1638
Field:
	name=ID COLON expr=Expr;

	// parse_block_tail_, libsyntax/parser/parser.rs, line 3248
ExprBlock:
	block=Block;

Block:
	{Block} LBRACE
	// parse_items_and_view_items, libsyntax/parser/parser.rs, line 4965
	=> innerAttrs+=InnerAttributes*
	// parse_mod_items
	// parse_stmt
	// TODO StmtMac
	=> items+=Stmt*
	// ERROR Parse outer attributes here, and use to raise an error
	expr=Expr_RestrictStmt?
	RBRACE;

	// parse_stmt, libsyntax/parser/parser.rs, line 3092
Stmt:
// TODO evaluate maybe_whole!
	StmtDecl SEMI |
	// TODO macro invocation
	// TODO Semi-colon statement terminators
	Item |
	// TODO Grammar refers to foreign item, but this grammar expects foreign items in expect blocks
	=>Expr_NoSemi SEMI? |
	// ForeignItem | 
	Expr_RestrictStmt SEMI;

	// parse_let, libsyntax/parser/parser.rs, line 3602
StmtDecl:
	"let" decls+=Local (COMMA decls+=Local)*;

	// parse_local, libsyntax/parser/parser.rs, line 3041
Local:
	pat=Pat (COLON ty=Ty)? init=Initializer?;

	// parse_initializer, libsyntax/parser/parser.rs, line 2620
Initializer:
	EQ Expr;

	// parse_lambda_expr, libsyntax/parser/parser.rs, line 2468
LambdaExpr:
	{ExprFnBlock} decl=FnBlockDecl body=Expr;

	// parse_fn_block_decl, libsyntax/parser/parser.rs, line 3713
FnBlockDecl:
	{FnBlockDecl} (OROR | OR (args+=FnBlockArg (COMMA args+=FnBlockArg)*)? OR) returnTy=RetTy?;

	// parse_fn_block_arg, libsyntax/parser/parser.rs, line 1372
FnBlockArg:
	pat=Pat (COLON ty=Ty)?;

ExprProc:
	decl=ProcDecl body=Expr;

	// parse_proc_decl, libsyntax/parser/parser.rs, line 3745
ProcDecl:
	{FnBlockDecl} "proc" LPAREN (args+=FnBlockArg (COMMA args+=FnBlockArg)*)? RPAREN (RARROW returnTy=Ty)?;

ExprSelf:
	{ExprPath} "self" // TODO Parser parses further path here
;

// parse_if_expr, libsyntax/parser/parser.rs, line 2424
ExprIf:
	"if" cond=Expr thn=ExprBlock ("else" els=ExprBlock)?;

	// parse_for_expr, libsyntax/parser/parser.rs, line 2505
ExprFor:
	{ExprForLoop} "for" pat=Pat "in" expr=Expr loopBlock=ExprBlock;

	// parse_while_expr, libsyntax/parser/parser.rs, line 2518
ExprWhile:
	"while" cond=Expr body=ExprBlock;

	// parse_loop_expr, libsyntax/parser/parser.rs, line 2526
ExprLoop:
	"loop" ({ExprLoop} name=ID? body=ExprBlock /* TODO Hide obsolete syntax for now | {ExprAgain} lifetime=Lifetime? */);

ExprContinue:
	{ExprAgain} "continue" lifetime=LIFETIME;

	// parse_match_expr, libsyntax/parser/parser.rs, line 2568
ExprMatch:
	"match" discriminant=Expr LBRACE arm=Arm? RBRACE;

Arm:
	attributes=OuterAttributes? pats=Pats ("if" guard=Expr)? FAT_ARROW (=>expr=ExprBlock nextArm=Arm? | expr=Expr_RestrictStmt (COMMA nextArm=Arm?)?);

	// parse_pats, libsyntax/parser/parser.rs, line 2630
Pats:
	pats+=Pat (OR pats+=Pat)*;

UnsafeBlock:
	"unsafe" block=ExprBlock;

ExprRet:
// can_begin_expr
	{ExprRet} "return" =>expr=Expr?;

ExprBreak:
	{ExprBreak} "break" lifetime=LIFETIME?;

ExprPath:
	path=PathWithLifetimeAndTypesWithColons;

	// parse_borrowed_pointee, libsyntax/parser/parser.rs, line 1313
TyRptr:
	AND lifetime=LIFETIME? mutTy=MutTy;

	// parse_ty_bare_fn, libsyntax/parser/parser.rs, line 890
/*
  [unsafe] [extern "ABI"] fn <'lt> (S) -> T
   ^~~~^           ^~~~^     ^~~~^ ^~^    ^
     |               |         |    |     |
     |               |         |    |   Return type
     |               |         |  Argument types
     |               |     Lifetimes
     |              ABI
  Function Style
*/
TyBareFn:
	fnStyle=FnStyle ("extern" abi=STRING?)? "fn" decl=FnDecl;

	// parse_unsafety, libsyntax/parser/parser.rs, line 1026
FnStyle:
	({UnstafeFn} "unsafe" | {NormalFn});

	// parse_ty_closure, libsyntax/parse/parser.rs, line 969
/*
  [unsafe] [once] <'lt> |S| [:Bounds] -> T
  ^~~~~~~^ ^~~~~^ ^~~~^  ^  ^~~~~~~~^    ^
    |        |      |    |      |        |
    |        |      |    |      |      Return type
    |        |      |    |  Closure bounds
    |        |      |  Argument types
    |        |    Lifetimes
    |     Once-ness (a.k.a., affine)
  Function Style
*/
TyClosure:
	fnStyle=FnStyle onceness=Onceness? lifetimes=Lifetimes? (OROR | OR args+=Arg (COMMA args+=Arg)* OR)
	bounds=TyParamBounds? retTy=RetTy;

Onceness:
	once?="once";

	// parse_lifetimes, libsyntax/parser/parser.rs, line 1586
Lifetimes:
	LT lifetimes+=LIFETIME => (COMMA lifetimes+=LIFETIME)* COMMA? GT;

	// parse_ret_ty, libsyntax/parse/parser.rs
RetTy:
	{RetTy} RARROW (ty=Ty | noReturn?=NOT);

	// parse_proc_type, libsyntax/parser/parser.rs, line 928
/*
  proc <'lt> (S) [:Bounds] -> T
  ^~~^ ^~~~^  ^  ^~~~~~~~^    ^
   |     |    |      |        |
   |     |    |      |      Return type
   |     |    |    Bounds
   |     |  Argument types
   |   Lifetimes
  the `proc` keyword
*/
TyProc:
	"proc" lifetimes=Lifetimes? /* not named, not variadic */ fnArgs=FnArgs bounds=TyParamBounds retTy=RetTy;

	// parse_fn_args, libsyntax/parser/parser.rs, line 3485
FnArgs:
	{FnArgs} LPAREN (args+=Arg => (COMMA args+=Arg)* COMMA?)? RPAREN;

	// parse_path, libsyntax/parser/parser.rs, line 1463
TyPath:
	path=PathWithLifetimesTypesAndBounds;

PathWithLifetimesTypesAndBounds:
// TODO Is this missing the trailing generic params?
// TODO Cross-reference modules
	global?=MOD_SEP? segments+=PathSegment => (MOD_SEP segments+=PathSegment)* (bounds=TyParamBounds
	genericValues=GenericValues?)?;

PathWithLifetimeAndTypesWithColons:
// TODO Cross-reference modules
	global?=MOD_SEP? segments+=ExprPathSegment (MOD_SEP segments+=ExprPathSegment)*;
	
PathWithLifetimeAndTypesWithoutColons:
// TODO Cross-reference modules
	global?=MOD_SEP? segments+=PathWithLifetimeAndTypesWithoutColonsSegment (MOD_SEP segments+=PathWithLifetimeAndTypesWithoutColonsSegment)*;

PathSegment:
	name=ID genericValues=GenericValues?;

ExprPathSegment:
	{PathSegment} name=ID genericValues=ExprGenericValues?;
	
PathWithLifetimeAndTypesWithoutColonsSegment:
	{PathSegment} name=ID genericValues=GenericValues?;

	// parse_generic_values_after_lt, libsyntax/parser/parser.rs, line 
GenericValues:
	LT (lifetimes+=LIFETIME => (COMMA lifetimes+=LIFETIME)* COMMA)? tys+=Ty => (COMMA tys+=Ty)* COMMA? GT;

	// parse_generic_values_after_lt, libsyntax/parser/parser.rs, line 
ExprGenericValues:
	MOD_SEP GenericValues;

	// parse_mod_items, libsyntax/parser/parser.rs, line 4059
Mod:
	{Mod}
	// parse_inner_attrs_and_next
	// parse_items_and_view_items, libsyntax/parser/parser.rs, line 4965
	innerAttrs+=InnerAttributes*
	// parse_mod_items
	items+=Item*;

	/*ItemsAndViewItems:
	
;*/

// parse_token_tree, libsyntax/parser/parser.rs, line 2043
TT:
// TODO Invoke maybe_whole!
	{TTDelim} LBRACKET tts+=TT* RBRACKET | {TTDelim} LPAREN tts+=TT* RPAREN | {TTDelim} LBRACE tts+=TT* RBRACE |
	NonDelimTTToken;

	// parse_token_tree::parse_non_delim_tt_tok, libsyntax/parser/parser.rs, line 2043
NonDelimTTToken:
// TODO Invoke maybe_whole!
	DOLLAR ({TTSeq} LPAREN tts+=TT* RPAREN (separator=(NOT_MACRO_TOKEN | DOLLAR)? (zerok?=STAR | PLUS)) | {TTNonterminal}
	name=ID) |
	// parse_token_tree::parse_any_tt_tok, libsyntax/parser/parser.rs, line 2099
	TTTok;

TTTok:
	token=(EQ |
	LT |
	LE |
	EQEQ |
	NE |
	GE |
	GT |
	AND |
	OR |
	CARET |
	ANDAND |
	OROR |
	NOT |
	TILDE |
	PLUS |
	MINUS |
	STAR |
	SLASH |
	PERCENT |
	SHL |
	SHR |

	// Structural
	AT |
	DOT |
	DOTDOT |
	DOTDOTDOT |
	COMMA |
	SEMI |
	COLON |
	MOD_SEP |
	RARROW |
	LARROW |
	DARROW |
	FAT_ARROW |
	/*LPAREN |
	RPAREN |
	LBRACKET |
	RBRACKET |
	LBRACE |
	RBRACE |*/
	POUND |
	//DOLLAR |
	CHAR |
	STRING |
	FLOAT_UNSUFFIXED |
	FLOAT |
	INT_UNSUFFIXED |
	INT |
	UINT |
	ID |
	ML_COMMENT |
	SL_COMMENT |
	WS |
	NOT_MACRO_TOKEN |
	LIFETIME
	/* TODO Keywords */);

terminal EQ:
	'=';

terminal LT:
	'<';

terminal LE:
	'<=';

terminal EQEQ:
	'==';

terminal NE:
	'!=';

terminal GE:
	'>=';

terminal GT:
	'>';

terminal AND:
	'&';

terminal OR:
	'|';

terminal CARET:
	'^';

terminal ANDAND:
	'&&';

terminal OROR:
	'||';

terminal NOT:
	'!';

terminal TILDE:
	'~';

terminal PLUS:
	'+';

terminal MINUS:
	'-';

terminal STAR:
	'*';

terminal SLASH:
	'/';

terminal PERCENT:
	'%';

terminal SHL:
	"<<";

terminal SHR:
	">>";

	// Structural
terminal AT:
	'@';

terminal DOT:
	'.';

terminal DOTDOT:
	'..';

terminal DOTDOTDOT:
	'...';

terminal COMMA:
	',';

terminal SEMI:
	';';

terminal COLON:
	':';

terminal MOD_SEP:
	'::';

terminal RARROW:
	'->';

terminal LARROW:
	'<-';

terminal DARROW:
	'<->';

terminal FAT_ARROW:
	'=>';

terminal LPAREN:
	'(';

terminal RPAREN:
	')';

terminal LBRACKET:
	'[';

terminal RBRACKET:
	']';

terminal LBRACE:
	'{';

terminal RBRACE:
	'}';

terminal POUND:
	'#';

terminal DOLLAR:
	'$';

terminal CHAR:
	"'" (('\\' ('\\' | 'n' | 'r' | 't' | '0' | "'")) | UNICODE_CHAR | !('\\' | "'")) "'";

terminal STRING:
	'"' (('\\' ('\\' | 'n' | 'r' | 't' | '0' | '"' | '\n')) | UNICODE_CHAR | !('\\' | '"'))* '"';

terminal fragment UNICODE_CHAR:
	UTF8_CHAR | UTF16_CHAR | UTF32_CHAR;

terminal fragment UTF8_CHAR:
	'\\x' HEX_DIGIT HEX_DIGIT;

terminal fragment UTF16_CHAR:
	'\\u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

terminal fragment UTF32_CHAR:
	'\\U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

terminal fragment SIGNED_INT_TYPE:
	I | I8 | I16 | I32 | I64;

terminal fragment I:
	"i";

terminal fragment I8:
	"i8";

terminal fragment I16:
	"i16";

terminal fragment I32:
	"i32";

terminal fragment I64:
	"i64";

terminal fragment UNSIGNED_INT_TYPE:
	U | U8 | U16 | U32 | U64;

terminal fragment U:
	"u";

terminal fragment U8:
	"u8";

terminal fragment U16:
	"u16";

terminal fragment U32:
	"u32";

terminal fragment U64:
	"u64";

terminal fragment FLOAT_SUFFIX:
	F32 | F64;

terminal fragment F32:
	"f32";

terminal fragment F64:
	"f64";

	// Floating point literal
terminal FLOAT_UNSUFFIXED:
	DEC_DIGIT (DEC_DIGIT | '_')* ('.' (DEC_DIGIT | '_')+) (('E' | 'e') ('+' | '-')? (DEC_DIGIT | '_')+)?;

terminal FLOAT:
	FLOAT_UNSUFFIXED FLOAT_SUFFIX;

	// Integer literal
terminal INT_UNSUFFIXED:
	(DEC_INT_LIT | BIN_INT_LIT | OCT_INT_LIT | HEX_INT_LIT);

terminal INT:
	INT_UNSUFFIXED SIGNED_INT_TYPE;

terminal UINT:
	INT_UNSUFFIXED UNSIGNED_INT_TYPE;

	// Decimal (base 10) integer
terminal fragment DEC_INT_LIT:
	DEC_DIGIT (DEC_DIGIT | '_')*;

	// Binary (base 2) integer
terminal fragment BIN_INT_LIT:
	"0b" ('0' | '1' | '_')+;

	// Octal (base 8) integer
terminal fragment OCT_INT_LIT:
	"0o" (OCT_DIGIT | '_')+;

	// Hex (base 16) integer
terminal fragment HEX_INT_LIT:
	"0x" (HEX_DIGIT | '_')+;

terminal fragment OCT_DIGIT:
	'0'..'7';

terminal fragment DEC_DIGIT:
	'0'..'9';

terminal fragment HEX_DIGIT:
	'0'..'9' | 'a'..'f' | 'A'..'F';

	// parse_lifetime, libsyntax/parser/parser.rs, line 1566
// TODO Should be a token?
terminal LIFETIME:
	"'" ID;

	// terminal fragment NON_SPECIAL_CHAR: !('"' | '\'' | '\\' | 'n' | 'r' | 't' | '0');
terminal ID:
	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;

terminal ML_COMMENT:
	'/*'->'*/';

terminal SL_COMMENT:
	'//' !('\n' | '\r')* ('\r'? '\n')?;

terminal WS:
	(' ' | '\t' | '\r' | '\n')+;

terminal NOT_MACRO_TOKEN:
	!(DOLLAR | STAR | PLUS);