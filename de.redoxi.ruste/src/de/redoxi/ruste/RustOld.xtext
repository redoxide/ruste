grammar de.redoxi.ruste.Rust 
	with org.eclipse.xtext.common.Terminals

generate rust "http://www.redoxi.de/ruste/grammar/Rust"

Crate:
	(items += ItemAndAttrs)*
;

ItemAttr:
	'#[' attrs += Attr (',' attrs += Attr)* ']'
;

Attr:
	LiteralAttr |
	AttrWithList
;

// TODO Create return type
AttrWithList:
	ident = IDENT '(' attrs += Attr (',' attrs += Attr)* ')'
;

// TODO Create return type
LiteralAttr:
	ident = IDENT '=' (value = Literal)
;

ItemAndAttrs:
	(attrs += ItemAttr)*
	item = (ModItem | FnItem | TypeItem | StructItem | EnumItem | StaticItem | TraitItem | ImplItem | ExternBlock)
;

ModItem:
	"mod" ident = IDENT (';' | '{' body = Mod '}')
;

Mod: {ModBody}
	(viewItems += ViewItem | items += ItemAndAttrs)*
;

ViewItem:
	ExternModDecl | UseDecl
;

ExternModDecl:
	EXTERN "mod" ident = IDENT ('(' attrs += LinkAttr (',' attrs += LinkAttr)* ')')? ('=' externalIdent = StringLit)? ';'
;

LinkAttr:
	ident = IDENT '=' value = Literal
;

// TODO Return visibility enum by matching token
// TODO Match rules for internal vs external paths
UseDecl:
	vis = "pub"? "use" ident = IDENT ('=' externPath = Path | "::" path = PathGlob)
;

Path:
	components += IDENT ("::" components += IDENT)*
;

PathGlob:
	head += IDENT ("::" tail = PathGlob)? |
	head += "*" |
	'{' head += IDENT (',' head += IDENT)* '}'
;

// TODO Modifiers
FnItem:
	FnSignature "{" body = Block "}"
;

FnSignature:
	purity = Purity? "fn" ident = IDENT (generics = GenericParamDecls)? '(' (args += Arg (',' args += Arg)*)? ')' ("->" returnType = Type)?
;

Purity:
	UNSAFE | EXTERN
;

terminal UNSAFE:
	"unsafe"
;

terminal EXTERN:
	"extern"
;

// TODO Reduce to list
// TODO Lifetimes
GenericParamDecls:
	'<' params += GenericParamDecl (',' params += GenericParamDecl)* '>'
;

// TODO Crossreference Trait?
GenericParamDecl:
	ident = IDENT (':' bounds += IDENT ('+' bounds += IDENT))?
;

// TODO Crossreference generic param?
GenericParams:
	'<' params += IDENT (',' params += IDENT)* '>'
;

Arg:
	pat = Pat ':' type = Type
;

Type:
	PrimitiveType |			// ()
	{BottomType} BottomType |				// !
	BoxType |						// @T
	UniqType |					// ~T
	// VecType |						// [T]
	// FixedLenVecType | 	// TODO ?
	PtrType |						// TODO ?
	RptrType |					// TODO ?
	// ClosureType |				// || {}
	//BareFnType |				// TODO ?
	TupleType /*|					// (T, U)
	PathType						// a::b::T*/
;

PrimitiveType:
	{IntType} INT_TYPE |
	{FloatType} FLOAT_TYPE |
	{BoolType} BOOLEAN_TYPE |
	{MachineType} MACHINE_TYPE |
	{UnitType} UNIT_TYPE 
;

terminal INT_TYPE:
	SIGNED_INT_TYPE | UNSIGNED_INT_TYPE
;

terminal SIGNED_INT_TYPE:
	I8 | I16 | I32 | I64
;

terminal I8:
	"i8"
;

terminal I16:
	"i16"
;

terminal I32:
	"i32"
;

terminal I64:
	"i64"
;

terminal UNSIGNED_INT_TYPE:
	U8 | U16 | U32 | U64
;

terminal U8:
	"u8"
;

terminal U16:
	"u16"
;

terminal U32:
	"u32"
;

terminal U64:
	"u64"
;

terminal FLOAT_TYPE:
	F32 | F64
;

terminal F32:
	"f32"
;

terminal F64:
	"f64"
;

terminal BOOLEAN_TYPE:
	"bool"
;

terminal MACHINE_TYPE:
	MACHINE_INT_TYPE | MACHINE_UINT_TYPE
;

terminal MACHINE_INT_TYPE:
	"int"
;

terminal MACHINE_UINT_TYPE:
	"uint"
;

terminal UNIT_TYPE:
	UNIT_LIT
;

terminal NIL_TYPE:
	UNIT_LIT
;

BottomType:
	'!'
;

BoxType:
	"@" type = Type
;

UniqType:
	"~" type = Type
;

/*VecType:
	'[' type = Type ']'
;

FixedLenVecType:
	'[' type = Type ',' ".." size = Expr ']'
;*/

PtrType:
	"&" type = Type
;

RptrType:
	"*" type = Type
;

/*ClosureType: {ClosureType}
	'|' (argTypes += Type (',' argTypes += Type)*)? '|' ("->" returnType = Type)?
;*/

/*BareFnType:
	
;*/

TupleType:
	'(' types += Type (',' types += Type)* ')'
;

/*PathType:
	// TODO Crossreference traits
	path = Path "::"? ('<' bounds += IDENT (',' bounds += IDENT)* '>')?
;*/

Pat:
	/*{SingleWildPattern} '_' |		// EnumVariant(_)
	{MultiWildPattern} ".." |		// EnumVariant(..)
	PatIdent |									// Ident or nullary enum
	PatEnum |										// Binding to enum match
	PatStruct |									// Struct pattern
	PatTup |										// Tuple pattern
	PatBox |										// Boxed pattern
	PatUniq |										// Owned pattern*/
	// PatRegion |									// ref pat
	// PatLit |										// Literal
	PatRange //|								// a..b
	//PatVec										// [a, b, ..i, y, z]
;

/*PatIdent:
	ident = IDENT
;

PatEnum:
	path = Path '(' (patterns += Pat (',' patterns += Pat)*) ')' 
;

PatStruct:
	path = Path '{' (patterns += FieldPat (',' patterns += FieldPat)*) '}'
;

FieldPat:
	ident = IDENT ':' pattern = Pat
;

PatTup:
	'(' patterns += Pat (',' patterns += Pat)* ')'
;

PatBox:
	"@" pattern = Pat
;

PatUniq:
	"~" pattern = Pat
;

PatRegion:
	// TODO Check this one
	// TODO Lifetime?
	"&" pattern = Pat	
;*/

/*PatLit:
	literal = Literal
;*/

PatRange:
	CharRange | IntRange
;

CharRange:
	start = CharLit ".." end = CharLit
;

IntRange:
	start = NumberLit ".." end = NumberLit
;

/*PatVec:
	'[' start += Pat (',' start += Pat)* (".." i = Pat (',' end += Pat)*)? ']'
;*/

BlockItem:
	unsafe ?= UNSAFE "{" block = Block "}"
;

Block: 
  {Block} (viewItems += ViewItem)* (stmts += Stmt)* expr = Expr?
;

Stmt:
	StmtDecl /*|				// item or local (let) binding
	StmtSemi |				// Expression with trailing semi-colon (may have any type TODO check?)
	StmtExpr //|				// Expression without trailing semi-colon (must have unit type TODO Check?) */
	// StmtMac						// TODO ?
;

StmtDecl:
	DeclLocal |				// let a = b;
	DeclItem					// Any other item declaration
;

DeclLocal:
	"let" pattern = Pat (':' type = Type)? ('='? expr = Expr)? ';'
;

DeclItem:
	item = ItemAndAttrs
;

StmtSemi:
	expr = Expr ';'
;

StmtExpr:
	expr = Expr
;

// Macro invocation
/*StmtMac:
	
;*/

Expr:
	// ExprLValue | 
	ExprRValue |
	ExprIf |
	ExprWhile |
	ExprForLoop |
	ExprLoop |
	ExprBlock
;

ExprLValue:
	ExprPath | ExprField | ExprIndex
;

// TODO Check order of operations
ExprRValue:
	ExprRValue1 |
	ExprCall | 
	ExprMethodCall | 
	// ExprVstore |
	ExprFnBlock |
	ExprDoBody |
	// TODO ExprAssign |
	// TODO ExprAssignOp |
	// TODO ExprLogLevel |
	// TODO ExprInlineAsm |
	ExprMatch |
	ExprStruct |
	ExprRepeat |
	ExprBinOp |
	ExprField |
	ExprIndex
;

// R-value expressions that don't start with an expression
ExprRValue1:
	ExprPath |
	ExprLit |
	ExprParen |
	{ExprSelf} ExprSelf |
	ExprAddrOf |
	ExprBreak |
	ExprAgain |
	ExprRet |
	// TODO ExprMac |
	ExprVec |
	ExprTup |
	ExprUnOp
;

// TODO How is this different to a vector expression that happens to be a pointer?
/*ExprVstore:
	ExprVstoreUniq |			// ~[1, 2, 3]
	ExprVstoreBoxed |			// @[1, 2, 3]
	ExprVstoreSlice |			// &[1, 2, 3]
	ExprVstoreMutSlice		// &mut [1, 2, 3]
;

ExprVstoreUniq:
	
;

ExprVstoreBoxed:
	
;

ExprVstoreSlice:
	
;

ExprVstoreMutSlice:
	
;*/

// TODO Is this syntax still valid, the reference manual doesn't mention it
/*ExprBox:
	"box" "(" (place = Expr)? ")" expr = Expr 
;*/

ExprVec:
	mutable ?= "mut" "[" exprs += Expr ("," exprs += Expr)* (".." repeatExpr = Expr)? "]"
;

// TODO Call sugar?
ExprCall:
	fnExpr = ExprRValue1 "(" (args += Expr ("," args += Expr)*)? ")"
;

// TODO Reference method
ExprMethodCall:
	structExpr = ExprRValue1 "." method = IDENT "(" (args += Expr ("," args += Expr)*)? ")"
;

ExprTup:
	"(" exprs += Expr ("," exprs += Expr)* ")"
;

ExprBinOp:
	ExprPrecedence12
	// TODO Compound assignment operators
;

ExprPrecedence12:
	Assign | ExprPrecedence11
;

ExprPrecedence11:
	BooleanOr | ExprPrecedence10
;

ExprPrecedence10:
	BooleanAnd | ExprPrecedence9
;

ExprPrecedence9:
	EqualTo | NotEqualTo | ExprPrecedence8
;

ExprPrecedence8:
	LessThan | GreaterThan | LessThanOrEqualTo | GreaterThanOrEqualTo | ExprPrecedence7
;

ExprPrecedence7:
	BitwiseOr | ExprPrecedence6
;

ExprPrecedence6:
	BitwiseXor | ExprPrecedence5
;

ExprPrecedence5:
	BitwiseAnd | ExprPrecedence4
;

ExprPrecedence4:
	LeftShift | RightShift | ExprPrecedence3
;

ExprPrecedence3:
	Addition | Subtraction | ExprPrecedence2
;

ExprPrecedence2:
	ExprCast | ExprPrecedence1
;

ExprPrecedence1:
	Multiplication | Division | Modulo
;

ExprPrecedence0:
	ExprUnOp | ExprRValue1 // TODO Next Expr production
;

Multiplication:
	left = ExprPrecedence0 "*" right = Expr
;

Division:
	left = ExprPrecedence0 "/" right = Expr
;

Modulo:
	left = ExprPrecedence0 "%" right = Expr
;

Addition:
	left = ExprPrecedence2 "+" right = ExprPrecedence2
;

Subtraction:
	left = ExprPrecedence2 "-" right = ExprPrecedence2
;

LeftShift:
	left = ExprPrecedence3 "<<" right = ExprPrecedence3
;

RightShift:
	left = ExprPrecedence3 ">>" right = ExprPrecedence3
;

BitwiseAnd:
	left = ExprPrecedence4 "&" right = ExprPrecedence4
;

BitwiseXor:
	left = ExprPrecedence5 "^" right = ExprPrecedence5
;

BitwiseOr:
	left = ExprPrecedence6 "|" right = ExprPrecedence6
;

LessThan:
	left = ExprPrecedence7 "<" right = ExprPrecedence7
;

GreaterThan:
	left = ExprPrecedence7 ">" right = ExprPrecedence7
;

LessThanOrEqualTo:
	left = ExprPrecedence7 "<=" right = ExprPrecedence7
;

GreaterThanOrEqualTo:
	left = ExprPrecedence7 ">=" right = ExprPrecedence7
;

EqualTo:
	left = ExprPrecedence8 "==" right = ExprPrecedence8
;

NotEqualTo:
	left = ExprPrecedence8 "!=" right = ExprPrecedence8
;

BooleanAnd:
	left = ExprPrecedence9 "&&" right = ExprPrecedence9
;

BooleanOr:
	left = ExprPrecedence10 "||" right = ExprPrecedence10
;

// TODO Divide expressions into lvalues and rvalues
Assign:
	left = ExprLValue "=" right = Expr
;

ExprUnOp:
	NumericNegation |
	Dereference |
	LogicalNegation |
	ManagedBox |
	OwnedBox |
	Borrow
;

NumericNegation:
	"-" expr = Expr
;

Dereference:
	"*" expr = Expr
;

LogicalNegation:
	"!" expr = Expr
;

ManagedBox:
	"@" expr = Expr
;

OwnedBox:
	"~" expr = Expr
;

Borrow:
	"&" expr = Expr
;

ExprLit:
	literal = Literal
;

ExprCast:
	expr = ExprPrecedence1 "as" type = Type
;

ExprIf:
	"if" condition = Expr "{" ifBlock = Block "}" ("else" (else = ExprIf | "{" elseBlock = Block "}"))?
;

ExprWhile:
	"while" expr = Expr "{" block = Block "}"
;

ExprForLoop:
	"for" pat = Pat "in" expr = Expr "{" block = Block "}"
;

ExprLoop:
	(label = Lifetime ":")? "loop" "{" block = Block "}" 
;

Lifetime:
	"'" label = IDENT
;

ExprMatch:
	"match" expr = Expr "{" matches += MatchArm ("|" matches += MatchArm)* "}"
;

MatchArm:
	pat = MatchPat "=>" (expr = Expr "," | "{" block = Block "}") 
;

MatchPat:
	pats += Pat (".." pats += Pat)? ("if" patternGuard = Expr)?
;

// TODO Lambda expression?
ExprFnBlock:
	"|" (args += IDENT ("," args += IDENT)*)? "|" ("->" type = Type)? expr = Expr
;

ExprDoBody:
	"do" expr = Expr ("|" (args += IDENT ("," args += IDENT)*)? "|")? "{" block = Block "}"
;

ExprBlock:
	"{" block = Block "}"
;

// TODO Assignment?
// TODO Is this parsed as a different expression than a binary operation that
// assigns
/*ExprAssign:
	
;*/

// TODO Assignment?
// TODO Is this parsed as a different expression than a binary operation that
// assigns
/*ExprAssignOp:
	
;*/

// TODO Reference trait or structure
ExprField:
	expr = ExprRValue1 "." field = IDENT
;

ExprIndex:
	expr = ExprRValue1 "[" indexExpr = Expr "]"
;

ExprPath:
	head = IDENT ("::" tail += ExprPathTail)+ 
;

ExprPathTail:
	// "<" types += TypeExpr ("," types += TypeExpr)* ">" |
	ExprPath
;

/*TypeExpr:
	
;*/

ExprSelf:
	"self"
;

ExprAddrOf:
	"&" mutable ?= "mut" expr = Expr
;

ExprBreak:
	"break" lifetime = Lifetime
;

ExprAgain:
	"loop" lifetime = Lifetime
;

ExprRet:
	"return" expr = Expr
;

/*ExprLogLevel:
	
;

ExprInlineAsm:
	
;*/

// Macro
/*ExprMac:
	
;*/

ExprStruct:
	StructExpr |
	TupleStructExpr |
	UnitStructExpr
;

StructExpr:
	path = ExprPath "{" fields += Field ("," fields += Field)* (".." baseExpr = Expr)? "}"
;

Field:
	ident = IDENT ":" expr = Expr
;

TupleStructExpr:
	path = ExprPath "(" fields += Expr ("," fields += Expr)* ")"
;

UnitStructExpr:
	path = ExprPath
;

ExprRepeat:
	"[" expr = Expr "," ".." repeatExpr = Expr "]"
;

ExprParen:
	"(" expr = Expr ")"
;

ExternBlock: {ExternBlock}
	// TODO String constant for ABI
	EXTERN "{" (functions += ForeignFn)* "}" 
;

ForeignFn:
	"fn" ident = IDENT "(" (args += Arg ("," args += Arg)*)? ")" ("->" returnType = Type)? ";"
;

ImplItem:
	"impl" (trait = IDENT "for")? struct = IDENT "{" (methods += ImplMethod)* "}"
;

// TODO Visibility
MethodSignature:
	purity = Purity "fn" ident = IDENT (generics = GenericParamDecls)? '(' (args += Arg (',' args += Arg)*)? ')' ("->" returnType = Type)?
;

ImplMethod:
	signature = MethodSignature "{" block = Block "}"
;

TraitMethod:
	signature = MethodSignature ";" |
	ImplMethod
;

TraitItem:
	"trait" ident = IDENT (generics = GenericParamDecls)? "{" (methods += TraitMethod)* "}"
;

StaticItem:
	"static" mutable ?= "mut" ident = IDENT ":" type = Type "=" expr = Expr ";"
;

EnumItem:
	"enum" ident = IDENT (generics = GenericParamDecls)? "{" variants += EnumVariant ("," variants += EnumVariant)* "}"
;

EnumVariant:
	ident = IDENT (generics = GenericParams)? ("(" types += Type ("," types += Type)* ")" | "{" fields += Field ("," fields += Field)* (".." baseExpr = Expr)? "}")?
;

StructItem:
	"struct" ident = IDENT (generics = GenericParamDecls)? ("(" types += Type ("," types += Type)* ")" | "{" fields += Field ("," fields += Field)* (".." baseExpr = Expr)? "}")
;

TypeItem:
	"type" ident = IDENT (generics = GenericParamDecls)? "=" originalType = Type ";" 
;

Literal:
	StringLit |
	CharLit |
	NumberLit
;

CharLit: {CharLit}
	'\'' (char = NON_SINGLE_QUOTE | '\\' (char = '\'' | escapedChar = EscapedChar)) '\''
;

EscapedChar:
	{EscapedChar} char = ('\\' | 'n' | 'r' | 't' | '0') |
	{UnicodeChar} 'x' (digits += HEX_DIGIT) (digits += HEX_DIGIT) |
	{UnicodeChar} 'u' (digits += HEX_DIGIT) (digits += HEX_DIGIT) (digits += HEX_DIGIT) (digits += HEX_DIGIT) |
	{UnicodeChar} 'U' (digits += HEX_DIGIT) (digits += HEX_DIGIT) (digits += HEX_DIGIT) (digits += HEX_DIGIT) (digits += HEX_DIGIT) (digits += HEX_DIGIT) (digits += HEX_DIGIT) (digits += HEX_DIGIT)
;

terminal NON_SINGLE_QUOTE:
	!'\''
;

terminal HEX_DIGIT:
	DEC_DIGIT | 'a'..'f' | 'A'..'F'
;

terminal DEC_DIGIT:
	'0'..'9'
;

terminal OCT_DIGIT:
	'0'..'7'
;

StringLit: 
	{StringLit} '"' (chars += StringChar)* '"' |
	{RawStringLit} 'r' '#' body = RawString? '#'
;

RawString:
	'"' RawStringBody '"' |
	'#' RawString '#'
;

RawStringBody:
	// Refer to String grammar in manual
	RAW_STRING_CHAR*
;

StringChar:
	char = NON_DOUBLE_QUOTE | 
	'\\' char = '"' | 
	'\\' escapedChar = EscapedChar
;

terminal RAW_STRING_CHAR:
	!'#'	// TODO This is not strictly correct, but for now will do
;

terminal NON_DOUBLE_QUOTE:
	!'"'
;

NumberLit:
	digits += NON_ZERO_DEC (digits += DEC_DIGIT | '_')* suffix = NumSuffix? |
	digits += '0' ( (digits += DEC_DIGIT | '_')* suffix = NumSuffix? |
				radix = 'b' (digits += '0' | digits += '1' | '_')+ suffix = IntSuffix? |
				radix = 'o' (digits += OCT_DIGIT | '_')+ suffix = IntSuffix? |
				radix = 'x' (digits += HEX_DIGIT | '_')+ suffix = IntSuffix?
			)
;

NumSuffix:
	IntSuffix | FloatSuffix
;

FloatSuffix:
	(exp = Exponent | '.' DecLit exp = Exponent?)? 'f' size = ("32" | "64")
;

DecLit:
	{DecLit} (digits += DEC_DIGIT | '_')+
;

Exponent:
	('E' | 'e') sign = ('+' | '-')? exp = DecLit
;

IntSuffix:
	UnsignedIntSuffix | SignedIntSuffix
;

SignedIntSuffix:
	'i' size = IntSuffixSize
;

UnsignedIntSuffix:
	'u' size = IntSuffixSize
;

IntSuffixSize:
	("8" | "16" | "32" | "64")
;

terminal NON_ZERO_DEC:
	'1'..'9'
;

// TODO Expand
terminal fragment XID_START:
	'a'..'z'
;

// TODO Expand
terminal fragment XID_CONTINUE:
	'a'..'z' | '_'
;

terminal IDENT:
	XID_START XID_CONTINUE*
;

terminal UNIT_LIT:
	"()"
;

BooleanLiteral:
	"true" | "false"
;
     
