grammar de.redoxi.ruste.Rust 

generate rust "http://www.redoxi.de/ruste/grammar/Rust"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// Top level crate and its implicit module
Crate:
	items+=ItemAndAttrs*
;

// Attribute for an item
ItemAttr:
	'#[' attrs+=Attr (',' attrs+=Attr)* ']'
;

// Individual attribute within an item
Attr:
	LiteralAttr |
	AttrWithList
;

// Attribute with a list of other attributes
AttrWithList:
	ident=IDENT '(' attrs+=Attr (',' attrs+=Attr)* ')'
;

// An attribute with a literal value
LiteralAttr:
	ident=IDENT '=' value=Literal
;

// An item and any associated attributes
ItemAndAttrs:
	attrs+=ItemAttr* item=Item
;

// Items within a module or crate
Item:
	ModItem | FnItem // | TypeItem | StructItem | EnumItem | StaticItem | TraitItem | ImplItem | ExternBlock
;

// A module declaration item
ModItem:
	"mod" ident=IDENT (externalBody?=';' | '{' items+=ItemAndAttrs* '}')
;

// Function item
FnItem:
	"fn" ident=IDENT ('<' params += GenericParamDecl (',' params += GenericParamDecl)* '>')? '(' (args += Arg (',' args += Arg)*)? ')' ("->" returnType = Type)? body = Block
;

Block:
	'{' /* TODO Statements, expression */ '}'
;

// TODO Crossreference Trait?
GenericParamDecl:
	ident = IDENT (':' bounds += IDENT ('+' bounds += IDENT))?
;

Arg:
	pat = Pat ':' type = Type
;

// TODO Expand
Pat:
	ident = IDENT
;

Type:
	PrimitiveType |
	TupleType |
	StructType |
	EnumType
;

PrimitiveType:
	{IntType} INT_TYPE |
	{FloatType} FLOAT_TYPE |
	{BoolType} BOOLEAN_TYPE |
	{MachineType} MACHINE_TYPE |
	{UnitType} UNIT_TYPE
;

TupleType:
	'(' types+=Type (',' types+=Type)* ')'
;

// TODO Move generics to own rule, but attach here
StructType:
	"struct" ident=IDENT ('<' params += GenericParamDecl (',' params += GenericParamDecl)* '>')? '{' fields+=StructField (',' fields+=StructField)* '}'
;

StructField:
	vis=Visibility? ident=IDENT ':' type=Type
;

EnumType:
	"enum" ident=IDENT ('<' params += GenericParamDecl (',' params += GenericParamDecl)* '>')? '{' variants+=Variant (',' variants+=Variant)* '}'
;

Variant:
	StructVariant | TupleVariant | UnitVariant
;

StructVariant:
	ident=IDENT ('<' params += GenericParamDecl (',' params += GenericParamDecl)* '>')? '{' fields+=StructField (',' fields+=StructField)* '}'
;

TupleVariant:
	ident=IDENT '(' types+=Type (',' types+=Type)* ')'
;

UnitVariant:
	ident=IDENT
;

enum Visibility:
	PRIVATE="priv" | PUBLIC="pub"	
;

terminal INT_TYPE: INT_SIZE;
terminal fragment INT_SIZE: SIGNED_INT_TYPE | UNSIGNED_INT_TYPE;
terminal fragment SIGNED_INT_TYPE: I8 | I16 | I32 | I64;
terminal fragment I8: "i8";
terminal fragment I16: "i16";
terminal fragment I32: "i32";
terminal fragment I64: "i64";
terminal fragment UNSIGNED_INT_TYPE: U8 | U16 | U32 | U64;
terminal fragment U8: "u8";
terminal fragment U16: "u16";
terminal fragment U32: "u32";
terminal fragment U64: "u64";
terminal FLOAT_TYPE: FLOAT_SIZE;
terminal fragment FLOAT_SIZE: F32 | F64;
terminal fragment F32: "f32";
terminal fragment F64: "f64";
terminal BOOLEAN_TYPE: "bool";
terminal MACHINE_TYPE: MACHINE_INT_TYPE | MACHINE_UINT_TYPE;
terminal fragment MACHINE_INT_TYPE: "int";
terminal fragment MACHINE_UINT_TYPE: "uint";
terminal UNIT_TYPE: "()";

StringLit: 
	value = STRING_LIT
	// | {RawStringLit} 'r' '#' body = RawString? '#'
;

// Literal value
Literal:
	NumberLit | CharLit | StringLit
;

NumberLit:
	value = (FLOAT_LIT | INT_LIT)
;

// Single character literal
CharLit:
	value = CHAR_LIT
;

terminal CHAR_LIT: "'" (('\\' ('\\' | 'n' | 'r' | 't' | '0')) | UNICODE_CHAR | !('\\' | "'"))* "'";
terminal STRING_LIT: '"' (('\\' ('\\' | 'n' | 'r' | 't' | '0')) | UNICODE_CHAR | !('\\' | '"'))* '"';

terminal fragment UNICODE_CHAR: UTF8_CHAR | UTF16_CHAR | UTF32_CHAR;
terminal fragment UTF8_CHAR: '\\x' HEX_DIGIT HEX_DIGIT;
terminal fragment UTF16_CHAR: '\\u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
terminal fragment UTF32_CHAR: '\\U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

// Floating point literal
terminal FLOAT_LIT: DEC_DIGIT (DEC_DIGIT | '_')* ('.' (DEC_DIGIT | '_')+) (('E' | 'e') ('+' | '-')? (DEC_DIGIT | '_')+)? FLOAT_SIZE?;

// Integer literal
terminal INT_LIT: (DEC_INT_LIT | BIN_INT_LIT | OCT_INT_LIT | HEX_INT_LIT) INT_SIZE?;

// Decimal (base 10) integer
terminal fragment DEC_INT_LIT: DEC_DIGIT (DEC_DIGIT | '_')*;

// Binary (base 2) integer
terminal fragment BIN_INT_LIT: "0b" ('0' | '1' | '_')+;

// Octal (base 8) integer
terminal fragment OCT_INT_LIT: "0o" (OCT_DIGIT | '_')+;

// Hex (base 16) integer
terminal fragment HEX_INT_LIT: "0x" (HEX_DIGIT | '_')+;

terminal fragment OCT_DIGIT: '0'..'7';
terminal fragment DEC_DIGIT: '0'..'9';
terminal fragment HEX_DIGIT: '0'..'9' | 'a'..'f' | 'A'..'F';

// terminal fragment NON_SPECIAL_CHAR: !('"' | '\'' | '\\' | 'n' | 'r' | 't' | '0');

terminal fragment XID_START: 'a'..'z'; // TODO Expand
terminal fragment XID_CONTINUE: 'a'..'z' | '_'; // TODO Expand
terminal IDENT: XID_START XID_CONTINUE*;


