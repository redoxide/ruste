grammar de.redoxi.ruste.Rust hidden(WS, SL_COMMENT, ML_COMMENT)

generate rust "http://www.redoxi.de/ruste/grammar/Rust" 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// Top level crate and its implicit module
Crate:
	viewItems+=ViewItem* items+=ItemAndAttrs*
;

ViewItem:
	ExternModDecl | UseDecl
;

ExternModDecl:
	"extern" "mod" name=IDENT ('(' attrs += LinkAttr (',' attrs += LinkAttr)* ')')? ('=' externalIdent=StringLit)? ';'
;

LinkAttr:
	ident=IDENT '=' value=Literal
;

// TODO Match rules for internal vs external paths
UseDecl:
	vis=Visibility? "use" name=IDENT ('=' externPath=TypePath | "::" path=PathGlob) ';'
;

PathGlob:
	head += IDENT ("::" tail=PathGlob)? |
	head += "*" |
	'{' head+=IDENT (',' head+=IDENT)* '}'
;

// Attribute for an item
ItemAttr:
	'#[' attrs+=Attr (',' attrs+=Attr)* ']'
;

// Individual attribute within an item
Attr:
	LiteralAttr |
	AttrWithList
;

// Attribute with a list of other attributes
AttrWithList:
	name=IDENT  '('  attrs+=Attr  (','  attrs+=Attr )* ')'
;

// An attribute with a literal value
LiteralAttr:
	name=IDENT '=' value=Literal
;

// An item and any associated attributes
ItemAndAttrs:
	attrs+=ItemAttr* item=Item
;

Item:
	ModItem | FnItem | TypeItem | StructItem | EnumItem | TraitItem | ImplItem | ExternBlock | StaticItem
;

// A module declaration item
ModItem:
	"mod" name=IDENT (externalBody?=';' | '{' viewItems+=ViewItem* items+=ItemAndAttrs* '}')
;

// Function item
FnItem:
	"fn" name=IDENT ('<' params += GenericParamDecl (',' params += GenericParamDecl)* '>')? ('(' (args+=Arg (','  args+=Arg)*)? ')' | '()') ("->" returnType = Type)? '{' body=Block '}'
;

// TODO Reference Type?
TypeItem:
	"type" name=IDENT ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? '=' type=Type ';'
;

StructItem:
	"struct" name=IDENT ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? '{' fields+=StructField (',' fields+=StructField)* '}'
;

EnumItem:
	"enum" name=IDENT ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? "{" variants+=EnumVariant ("," variants+=EnumVariant)* "}"
;

EnumVariant:
	name=IDENT ('<' params+=IDENT (',' params+=IDENT)* '>')? ("(" types+=Type ("," types+=Type)* ")" | "{" fields+=StructField ("," fields+=StructField)* /* TODO Wildcard pattern? */ "}")?
;

TraitItem:
	"trait" name=IDENT ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? "{" (methods+=TraitMethod)* "}"
;

TraitMethod:
	(unsafe?="unsafe" | extern?="extern")? vis=Visibility? "fn" name=IDENT ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? ('(' (args+=Arg (',' args+=Arg)*)? ')' | '()') ("->" returnType=Type)? ('{' body=Block '}' | ';')
;

// TODO Crossreference struct and trait
ImplItem:
	"impl" (trait=IDENT "for")? struct=IDENT "{" (methods+=ImplMethod)* "}"
;

ImplMethod:
	(unsafe?="unsafe" | extern?="extern")? "fn" name=IDENT ('<' params+=GenericParamDecl (',' params+=GenericParamDecl)* '>')? ('(' (args+=Arg (',' args+=Arg)*)? ')' | '()') ("->" returnType=Type)? '{' body=Block '}'
;

ExternBlock:
	{ExternBlock} "extern" abi=STRING_LIT? "{" (functions += ForeignFn)* "}" 
;

ForeignFn:
	"fn" name=IDENT ("(" (args+=Arg ("," args+=Arg)*)? ")" | '()') ("->" returnType=Type)? ";"
;

StaticItem:
	"static" mutable?=MUT_KEYWORD? name=IDENT (":" type=Type)? "=" expr=Expr ";"
;

Expr:
	ExprBinary |
	ExprLambda |
	ExprWhile |
	ExprLoop |
	ExprBreak |
	ExprContinue |
	ExprDo |
	ExprFor |
	ExprIf |
	ExprMatch |
	ExprReturn
;

ExprLValue:
	expr=ExprLeaf ({ExprField.expr=current} =>'.' field=IDENT | {ExprIndex.expr=current} =>'[' indexExpr=Expr ']')
;

ExprLeaf:
	ExprFnCall
;

ExprFnCall hidden():
	expr=ExprPrimary tail=ExprFnCallArgs?
;

ExprFnCallArgs hidden():
	{ExprFnCallArgs} ('()' | '(' WS? args+=Expr WS? (',' WS? args+=Expr WS?)* ')') tail=ExprFnCallArgs?
;

ExprPrimary:
	ExprLiteral |
	ExprGroup |
	ExprStruct |
	ExprVec |
	ExprPath
;

ExprLiteral:
	literal=Literal
;

ExprPathHead:
	path=ExprPath ({ExprStruct.path=current} struct=ExprStruct | {ExprTuple.path=current} tuple=ExprTuple)?
;

ExprGroup:
	'(' expr=Expr ({ExprTuple.exprs+=current} ',' (exprs+=Expr (',' exprs+=Expr)* ','?)?)? ')'
;

ExprTuple:
	'(' exprs+=Expr (',' exprs+=Expr)* ','? ')'
;

ExprStruct:
	"{" fields+=StructField ("," fields+=StructField)* (".." baseExpr = Expr)? "}"
;

ExprVec:
	'[' mutable?=MUT_KEYWORD (exprs+=Expr ',' (('..' lenExpr=Expr) | exprs+=Expr (',' exprs+=Expr)+))? ']'
;

ExprUnary:
	NumericNegation |
	Dereference |
	LogicalNegation |
	ManagedBox |
	OwnedBox |
	Borrow |
	ExprLeaf
;

NumericNegation hidden(SL_COMMENT, ML_COMMENT):
	"-" expr=ExprPrimary
;

Dereference hidden(SL_COMMENT, ML_COMMENT):
	"*" expr=ExprPrimary
;

LogicalNegation hidden(SL_COMMENT, ML_COMMENT):
	"!" expr=ExprPrimary
;

ManagedBox hidden(SL_COMMENT, ML_COMMENT):
	"@" expr=ExprPrimary
;

OwnedBox hidden(SL_COMMENT, ML_COMMENT):
	"~" expr=ExprPrimary
;

Borrow hidden(SL_COMMENT, ML_COMMENT):
	"&" expr=ExprPrimary
;

ExprBinary:
	Assign
;

DivisionMultiplicationOrModulo:
	ExprUnary =>({Division.left=current} "/" right=ExprUnary | {Multiplication.left=current} "*" right=ExprUnary | {Modulo.left=current} "%" right=ExprUnary)?
;

As:
	DivisionMultiplicationOrModulo =>({ExprCast.expr=current} 'as' type=Type)?
;

AdditionOrSubtraction:
	As =>({ExprAddition.left=current} "+" right=As | {ExprSubtraction.left=current} "-" right=As)?
;

ShiftOperator:
	AdditionOrSubtraction =>({ExprLeftShift.left=current} "<<" right=AdditionOrSubtraction | {ExprRightShift.left=current} ">>" right=AdditionOrSubtraction)?
;

BitwiseAnd:
	ShiftOperator =>({ExprBitwiseAnd.left=current} "&" right=ShiftOperator)?
;

BitwiseXor:
	BitwiseAnd =>({ExprBitwiseXor.left=current} "^" right=BitwiseAnd)?
;

BitwiseOr:
	BitwiseXor =>({ExprBitwiseOr.left=current} "|" right=BitwiseXor)?
;

ComparisonOperators:
	BitwiseOr =>({ExprLessThan.left=current} "<" right=BitwiseOr | {ExprGreaterThan.left=current} ">" right=BitwiseOr | {ExprLessThanOrEqualTo.left=current} "<=" right=BitwiseOr | {ExprGreaterThanOrEqualTo.left=current} ">=" right=BitwiseOr)?
;

EqualityOperator:
	ComparisonOperators =>({ExprEqualTo.left=current} "==" right=ComparisonOperators | {ExprNotEqualTo.left=current} "!=" right=ComparisonOperators)?
;

BooleanAnd:
	EqualityOperator =>({ExprBooleanAnd.left=current} "&&" right=EqualityOperator)?
;

BooleanOr:
	BooleanAnd =>({ExprBooleanOr.left=current} "||" right=BooleanAnd)?
;

// TODO Divide expressions into lvalues and rvalues
Assign:
	BooleanOr ({ExprAssign.left=current} "=" right=BooleanOr)?
;

ExprLambda:
	'|' (args+=IDENT (',' args+=IDENT)*)? '|' expr=Expr
;

ExprWhile:
	"while" expr=Expr '{' block=Block '}'
;

ExprLoop:
	(lifetime=LIFETIME ':')? 'loop' '{' block=Block '}'
;

ExprBreak:
	{ExprBreak} 'break' lifetime=LIFETIME?
;

ExprContinue:
	{ExprContinue} 'continue' lifetime=LIFETIME?
;

ExprDo:
	'do' expr=Expr '|' (args+=IDENT (',' args+=IDENT)*)? '|' '{' block=Block '}'
;

ExprFor:
	'for' pat=Pat 'in' expr=Expr '{' block=Block '}'
;

ExprIf:
	'if' expr=Expr '{' block=Block '}' else=ElseTail?
;

ElseTail:
	'else' (ExprIf | '{' block=Block '}')
;

ExprMatch:
	'match' expr=Expr '{' arms+=MatchArm ('|' arms+=MatchArm)* '}'
;

MatchArm:
	matchPat=(MatchPat | PatEnum) '=>' (expr=Expr ',' | '{' block=Block '}')
;

MatchPat:
	pat=Pat ('..' endPat=Pat)? ('if' expr=Expr)
;

// TODO Expression is optional
ExprReturn:
	{ExprReturn} 'return' expr=Expr?
;

// Left-factored. Bit messy
Block:
	{Block} stmts+=Stmt (';' stmts+=Stmt)* ';'?
;

Stmt:
	SlotDeclStmt |
	ExprStmt
;

SlotDeclStmt:
	'let' pat=Pat (':' type=Type)? '=' expr=Expr ';'
;

ExprStmt:
	expr=Expr
;

// TODO Crossreference Trait?
GenericParamDecl:
	name=IDENT (':' bounds+=IDENT ('+' bounds+=IDENT)* )?
;

// TODO Crossreference Type
Arg:
	pat=Pat ':' type=Type
;

// TODO Expand
// See line 2869 of libsyntax/parse/parser.rs
Pat:
	PatWildcard |														
	PatIdent |
	PatBoxed |
	PatOwned |
	PatBorrowed |
	PatTuple |
	PatVector |
	PatLiteral
;

PatWildcard:
	{PatWildcard} '_'
;

PatIdent:
	(mutable?=MUT_KEYWORD)? name=IDENT
;

PatBoxed hidden(SL_COMMENT, ML_COMMENT):
	"@" pattern=Pat
;

PatOwned hidden(SL_COMMENT, ML_COMMENT):
	"~" pattern=Pat
;

PatBorrowed hidden(SL_COMMENT, ML_COMMENT):
	"&" pattern=Pat
;

PatTuple:
	'(' patterns+=Pat (',' patterns+=Pat)* ')'
;

PatVector:
	'[' patterns+=Pat (',' patterns+=Pat)* ']'
;

PatLiteral:
	literal=Literal
;

PatEnum:
	path=ExprPath ({PatTupleEnum.path=current} '(' ('*' | '..' | patterns+=Pat (',' patterns+=Pat)*) ')' | {PatStructEnum.path=current} '{' fieldPatterns+=FieldPat (',' fieldPatterns+=FieldPat)* '}')
;

FieldPat:
	name=IDENT (':' pattern=Pat)?
;

TypePath hidden(ML_COMMENT):
	segments+=IDENT ('::' segments+=IDENT)* (=>'<' (lifetimes+=LIFETIME | genericTypes+=Type) (',' (lifetimes+=LIFETIME | genericTypes+=Type))+ '>')?
;

ExprPath hidden(ML_COMMENT):
	segments+=IDENT ('::' segments+=IDENT)* ('::<' (lifetimes+=LIFETIME | genericTypes+=Type) (',' (lifetimes+=LIFETIME | genericTypes+=Type))* '>')?
;

terminal LIFETIME:
	"'" IDENT
;

Type:
	PrimitiveType |
	TextualType |
	NamedType |
	BoxedPointer |
	OwnedPointer |
	BorrowedPointer
;

PrimitiveType:
	{IntType} INT_TYPE |
	{FloatType} FLOAT_TYPE |
	{BoolType} BOOLEAN_TYPE |
	{MachineType} MACHINE_TYPE |
	{UnitType} '()'
;

TextualType:
	{CharType} 'char' |
	{BoxedStrType} '@str' |
	{OwnedStrType} '~str' |
	{BorrowedStrType} '&str'
;

NamedType:
	path=TypePath
;

BoxedPointer hidden(SL_COMMENT, ML_COMMENT):
	"@" type=Type
;

OwnedPointer hidden(SL_COMMENT, ML_COMMENT):
	"~" type=Type
;

BorrowedPointer hidden(SL_COMMENT, ML_COMMENT):
	"&" type=Type
;

StructField:
	vis=Visibility? name=IDENT ':' type=Type
;

Variant:
	StructVariant | TupleVariant | UnitVariant
;

StructVariant:
	name=IDENT ('<' params += GenericParamDecl (',' params += GenericParamDecl)* '>')? '{' fields+=StructField (',' fields+=StructField)* '}'
;

TupleVariant:
	name=IDENT '(' types+=Type (',' types+=Type)* ')'
;

UnitVariant:
	name=IDENT
;

enum Visibility:
	PRIVATE="priv" | PUBLIC="pub"	
;

terminal INT_TYPE: INT_SIZE;
terminal fragment INT_SIZE: SIGNED_INT_TYPE | UNSIGNED_INT_TYPE;
terminal fragment SIGNED_INT_TYPE: I8 | I16 | I32 | I64;
terminal fragment I8: "i8";
terminal fragment I16: "i16";
terminal fragment I32: "i32";
terminal fragment I64: "i64";
terminal fragment UNSIGNED_INT_TYPE: U8 | U16 | U32 | U64;
terminal fragment U8: "u8";
terminal fragment U16: "u16";
terminal fragment U32: "u32";
terminal fragment U64: "u64";
terminal FLOAT_TYPE: FLOAT_SIZE;
terminal fragment FLOAT_SIZE: F32 | F64;
terminal fragment F32: "f32";
terminal fragment F64: "f64";
terminal BOOLEAN_TYPE: "bool";
terminal MACHINE_TYPE: MACHINE_INT_TYPE | MACHINE_UINT_TYPE;
terminal fragment MACHINE_INT_TYPE: "int";
terminal fragment MACHINE_UINT_TYPE: "uint";

terminal MUT_KEYWORD: 'mut';
// TODO Add all keywords

StringLit: 
	value = STRING_LIT
	// | {RawStringLit} 'r' '#' body = RawString? '#'
;

// Literal value
Literal:
	NumberLit | CharLit | StringLit
;

NumberLit:
	value = (FLOAT_LIT | INT_LIT)
;

// Single character literal
CharLit:
	value = CHAR_LIT
;

terminal CHAR_LIT: "'" (('\\' ('\\' | 'n' | 'r' | 't' | '0')) | UNICODE_CHAR | !('\\' | "'"))* "'";
terminal STRING_LIT: '"' (('\\' ('\\' | 'n' | 'r' | 't' | '0')) | UNICODE_CHAR | !('\\' | '"'))* '"';

terminal fragment UNICODE_CHAR: UTF8_CHAR | UTF16_CHAR | UTF32_CHAR;
terminal fragment UTF8_CHAR: '\\x' HEX_DIGIT HEX_DIGIT;
terminal fragment UTF16_CHAR: '\\u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
terminal fragment UTF32_CHAR: '\\U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

// Floating point literal
terminal FLOAT_LIT: DEC_DIGIT (DEC_DIGIT | '_')* ('.' (DEC_DIGIT | '_')+) (('E' | 'e') ('+' | '-')? (DEC_DIGIT | '_')+)? FLOAT_SIZE?;

// Integer literal
terminal INT_LIT: (DEC_INT_LIT | BIN_INT_LIT | OCT_INT_LIT | HEX_INT_LIT) INT_SIZE?;

// Decimal (base 10) integer
terminal fragment DEC_INT_LIT: DEC_DIGIT (DEC_DIGIT | '_')*;

// Binary (base 2) integer
terminal fragment BIN_INT_LIT: "0b" ('0' | '1' | '_')+;

// Octal (base 8) integer
terminal fragment OCT_INT_LIT: "0o" (OCT_DIGIT | '_')+;

// Hex (base 16) integer
terminal fragment HEX_INT_LIT: "0x" (HEX_DIGIT | '_')+;

terminal fragment OCT_DIGIT: '0'..'7';
terminal fragment DEC_DIGIT: '0'..'9';
terminal fragment HEX_DIGIT: '0'..'9' | 'a'..'f' | 'A'..'F';

// terminal fragment NON_SPECIAL_CHAR: !('"' | '\'' | '\\' | 'n' | 'r' | 't' | '0');

terminal fragment XID_START: 'a'..'z' | 'A'..'Z' | '_'; // TODO Expand
terminal fragment XID_CONTINUE: XID_START | '0'..'9'; // TODO Expand
terminal IDENT: XID_START XID_CONTINUE*;

terminal WS:
	(' ' | '\t' | '\n' | '\r')+
;

terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;
